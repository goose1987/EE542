ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 18, 4
  12              		.thumb
  13              		.file	"UART_1.c"
  14              		.section	.debug_abbrev,"",%progbits
  15              	.Ldebug_abbrev0:
  16              		.section	.debug_info,"",%progbits
  17              	.Ldebug_info0:
  18              		.section	.debug_line,"",%progbits
  19              	.Ldebug_line0:
  20 0000 DE010000 		.text
  20      02005F00 
  20      00000201 
  20      FB0E0D00 
  20      01010101 
  21              	.Ltext0:
  22              		.cfi_sections	.debug_frame
  23              		.global	UART_1_initVar
  24              		.bss
  25              		.type	UART_1_initVar, %object
  26              		.size	UART_1_initVar, 1
  27              	UART_1_initVar:
  28 0000 00       		.space	1
  29              		.section	.text.UART_1_Start,"ax",%progbits
  30              		.align	2
  31              		.global	UART_1_Start
  32              		.thumb
  33              		.thumb_func
  34              		.type	UART_1_Start, %function
  35              	UART_1_Start:
  36              	.LFB0:
  37              		.file 1 ".\\Generated_Source\\PSoC5\\UART_1.c"
   1:.\Generated_Source\PSoC5/UART_1.c **** /*******************************************************************************
   2:.\Generated_Source\PSoC5/UART_1.c **** * File Name: UART_1.c
   3:.\Generated_Source\PSoC5/UART_1.c **** * Version 2.30
   4:.\Generated_Source\PSoC5/UART_1.c **** *
   5:.\Generated_Source\PSoC5/UART_1.c **** * Description:
   6:.\Generated_Source\PSoC5/UART_1.c **** *  This file provides all API functionality of the UART component
   7:.\Generated_Source\PSoC5/UART_1.c **** *
   8:.\Generated_Source\PSoC5/UART_1.c **** * Note:
   9:.\Generated_Source\PSoC5/UART_1.c **** *
  10:.\Generated_Source\PSoC5/UART_1.c **** ********************************************************************************
  11:.\Generated_Source\PSoC5/UART_1.c **** * Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
  12:.\Generated_Source\PSoC5/UART_1.c **** * You may use this file only in accordance with the license, terms, conditions,
  13:.\Generated_Source\PSoC5/UART_1.c **** * disclaimers, and limitations in the end user license agreement accompanying
  14:.\Generated_Source\PSoC5/UART_1.c **** * the software package with which this file was provided.
  15:.\Generated_Source\PSoC5/UART_1.c **** *******************************************************************************/
  16:.\Generated_Source\PSoC5/UART_1.c **** 
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 2


  17:.\Generated_Source\PSoC5/UART_1.c **** #include "UART_1.h"
  18:.\Generated_Source\PSoC5/UART_1.c **** #include "CyLib.h"
  19:.\Generated_Source\PSoC5/UART_1.c **** #if(UART_1_INTERNAL_CLOCK_USED)
  20:.\Generated_Source\PSoC5/UART_1.c ****     #include "UART_1_IntClock.h"
  21:.\Generated_Source\PSoC5/UART_1.c **** #endif /* End UART_1_INTERNAL_CLOCK_USED */
  22:.\Generated_Source\PSoC5/UART_1.c **** 
  23:.\Generated_Source\PSoC5/UART_1.c **** 
  24:.\Generated_Source\PSoC5/UART_1.c **** /***************************************
  25:.\Generated_Source\PSoC5/UART_1.c **** * Global data allocation
  26:.\Generated_Source\PSoC5/UART_1.c **** ***************************************/
  27:.\Generated_Source\PSoC5/UART_1.c **** 
  28:.\Generated_Source\PSoC5/UART_1.c **** uint8 UART_1_initVar = 0u;
  29:.\Generated_Source\PSoC5/UART_1.c **** #if( UART_1_TX_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
  30:.\Generated_Source\PSoC5/UART_1.c ****     volatile uint8 UART_1_txBuffer[UART_1_TXBUFFERSIZE];
  31:.\Generated_Source\PSoC5/UART_1.c ****     volatile uint8 UART_1_txBufferRead = 0u;
  32:.\Generated_Source\PSoC5/UART_1.c ****     uint8 UART_1_txBufferWrite = 0u;
  33:.\Generated_Source\PSoC5/UART_1.c **** #endif /* End UART_1_TX_ENABLED */
  34:.\Generated_Source\PSoC5/UART_1.c **** #if( ( UART_1_RX_ENABLED || UART_1_HD_ENABLED ) && \
  35:.\Generated_Source\PSoC5/UART_1.c ****      (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH) )
  36:.\Generated_Source\PSoC5/UART_1.c ****     volatile uint8 UART_1_rxBuffer[UART_1_RXBUFFERSIZE];
  37:.\Generated_Source\PSoC5/UART_1.c ****     volatile uint8 UART_1_rxBufferRead = 0u;
  38:.\Generated_Source\PSoC5/UART_1.c ****     volatile uint8 UART_1_rxBufferWrite = 0u;
  39:.\Generated_Source\PSoC5/UART_1.c ****     volatile uint8 UART_1_rxBufferLoopDetect = 0u;
  40:.\Generated_Source\PSoC5/UART_1.c ****     volatile uint8 UART_1_rxBufferOverflow = 0u;
  41:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_RXHW_ADDRESS_ENABLED)
  42:.\Generated_Source\PSoC5/UART_1.c ****         volatile uint8 UART_1_rxAddressMode = UART_1_RXADDRESSMODE;
  43:.\Generated_Source\PSoC5/UART_1.c ****         volatile uint8 UART_1_rxAddressDetected = 0u;
  44:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* End EnableHWAddress */
  45:.\Generated_Source\PSoC5/UART_1.c **** #endif /* End UART_1_RX_ENABLED */
  46:.\Generated_Source\PSoC5/UART_1.c **** 
  47:.\Generated_Source\PSoC5/UART_1.c **** 
  48:.\Generated_Source\PSoC5/UART_1.c **** /*******************************************************************************
  49:.\Generated_Source\PSoC5/UART_1.c **** * Function Name: UART_1_Start
  50:.\Generated_Source\PSoC5/UART_1.c **** ********************************************************************************
  51:.\Generated_Source\PSoC5/UART_1.c **** *
  52:.\Generated_Source\PSoC5/UART_1.c **** * Summary:
  53:.\Generated_Source\PSoC5/UART_1.c **** *  Initialize and Enable the UART component.
  54:.\Generated_Source\PSoC5/UART_1.c **** *  Enable the clock input to enable operation.
  55:.\Generated_Source\PSoC5/UART_1.c **** *
  56:.\Generated_Source\PSoC5/UART_1.c **** * Parameters:
  57:.\Generated_Source\PSoC5/UART_1.c **** *  None.
  58:.\Generated_Source\PSoC5/UART_1.c **** *
  59:.\Generated_Source\PSoC5/UART_1.c **** * Return:
  60:.\Generated_Source\PSoC5/UART_1.c **** *  None.
  61:.\Generated_Source\PSoC5/UART_1.c **** *
  62:.\Generated_Source\PSoC5/UART_1.c **** * Global variables:
  63:.\Generated_Source\PSoC5/UART_1.c **** *  The UART_1_intiVar variable is used to indicate initial
  64:.\Generated_Source\PSoC5/UART_1.c **** *  configuration of this component. The variable is initialized to zero (0u)
  65:.\Generated_Source\PSoC5/UART_1.c **** *  and set to one (1u) the first time UART_Start() is called. This allows for
  66:.\Generated_Source\PSoC5/UART_1.c **** *  component initialization without re-initialization in all subsequent calls
  67:.\Generated_Source\PSoC5/UART_1.c **** *  to the UART_1_Start() routine.
  68:.\Generated_Source\PSoC5/UART_1.c **** *
  69:.\Generated_Source\PSoC5/UART_1.c **** * Reentrant:
  70:.\Generated_Source\PSoC5/UART_1.c **** *  No.
  71:.\Generated_Source\PSoC5/UART_1.c **** *
  72:.\Generated_Source\PSoC5/UART_1.c **** *******************************************************************************/
  73:.\Generated_Source\PSoC5/UART_1.c **** void UART_1_Start(void) 
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 3


  74:.\Generated_Source\PSoC5/UART_1.c **** {
  38              		.loc 1 74 0
  39              		.cfi_startproc
  40              		@ args = 0, pretend = 0, frame = 0
  41              		@ frame_needed = 1, uses_anonymous_args = 0
  42 0000 80B5     		push	{r7, lr}
  43              	.LCFI0:
  44              		.cfi_def_cfa_offset 8
  45 0002 00AF     		add	r7, sp, #0
  46              		.cfi_offset 14, -4
  47              		.cfi_offset 7, -8
  48              	.LCFI1:
  49              		.cfi_def_cfa_register 7
  75:.\Generated_Source\PSoC5/UART_1.c ****     /* If not Initialized then initialize all required hardware and software */
  76:.\Generated_Source\PSoC5/UART_1.c ****     if(UART_1_initVar == 0u)
  50              		.loc 1 76 0
  51 0004 40F20003 		movw	r3, #:lower16:UART_1_initVar
  52 0008 C0F20003 		movt	r3, #:upper16:UART_1_initVar
  53 000c 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
  54 000e 002B     		cmp	r3, #0
  55 0010 08D1     		bne	.L2
  77:.\Generated_Source\PSoC5/UART_1.c ****     {
  78:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_Init();
  56              		.loc 1 78 0
  57 0012 FFF7FEFF 		bl	UART_1_Init
  79:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_initVar = 1u;
  58              		.loc 1 79 0
  59 0016 40F20003 		movw	r3, #:lower16:UART_1_initVar
  60 001a C0F20003 		movt	r3, #:upper16:UART_1_initVar
  61 001e 4FF00102 		mov	r2, #1
  62 0022 1A70     		strb	r2, [r3, #0]
  63              	.L2:
  80:.\Generated_Source\PSoC5/UART_1.c ****     }
  81:.\Generated_Source\PSoC5/UART_1.c ****     UART_1_Enable();
  64              		.loc 1 81 0
  65 0024 FFF7FEFF 		bl	UART_1_Enable
  82:.\Generated_Source\PSoC5/UART_1.c **** }
  66              		.loc 1 82 0
  67 0028 80BD     		pop	{r7, pc}
  68              		.cfi_endproc
  69              	.LFE0:
  70              		.size	UART_1_Start, .-UART_1_Start
  71 002a 00BF     		.section	.text.UART_1_Init,"ax",%progbits
  72              		.align	2
  73              		.global	UART_1_Init
  74              		.thumb
  75              		.thumb_func
  76              		.type	UART_1_Init, %function
  77              	UART_1_Init:
  78              	.LFB1:
  83:.\Generated_Source\PSoC5/UART_1.c **** 
  84:.\Generated_Source\PSoC5/UART_1.c **** 
  85:.\Generated_Source\PSoC5/UART_1.c **** /*******************************************************************************
  86:.\Generated_Source\PSoC5/UART_1.c **** * Function Name: UART_1_Init
  87:.\Generated_Source\PSoC5/UART_1.c **** ********************************************************************************
  88:.\Generated_Source\PSoC5/UART_1.c **** *
  89:.\Generated_Source\PSoC5/UART_1.c **** * Summary:
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 4


  90:.\Generated_Source\PSoC5/UART_1.c **** *  Initialize component's parameters to the parameters set by user in the
  91:.\Generated_Source\PSoC5/UART_1.c **** *  customizer of the component placed onto schematic. Usually called in
  92:.\Generated_Source\PSoC5/UART_1.c **** *  UART_1_Start().
  93:.\Generated_Source\PSoC5/UART_1.c **** *
  94:.\Generated_Source\PSoC5/UART_1.c **** * Parameters:
  95:.\Generated_Source\PSoC5/UART_1.c **** *  None.
  96:.\Generated_Source\PSoC5/UART_1.c **** *
  97:.\Generated_Source\PSoC5/UART_1.c **** * Return:
  98:.\Generated_Source\PSoC5/UART_1.c **** *  None.
  99:.\Generated_Source\PSoC5/UART_1.c **** *
 100:.\Generated_Source\PSoC5/UART_1.c **** *******************************************************************************/
 101:.\Generated_Source\PSoC5/UART_1.c **** void UART_1_Init(void) 
 102:.\Generated_Source\PSoC5/UART_1.c **** {
  79              		.loc 1 102 0
  80              		.cfi_startproc
  81              		@ args = 0, pretend = 0, frame = 0
  82              		@ frame_needed = 1, uses_anonymous_args = 0
  83              		@ link register save eliminated.
  84 0000 80B4     		push	{r7}
  85              	.LCFI2:
  86              		.cfi_def_cfa_offset 4
  87 0002 00AF     		add	r7, sp, #0
  88              		.cfi_offset 7, -4
  89              	.LCFI3:
  90              		.cfi_def_cfa_register 7
 103:.\Generated_Source\PSoC5/UART_1.c ****     #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 104:.\Generated_Source\PSoC5/UART_1.c **** 
 105:.\Generated_Source\PSoC5/UART_1.c ****         #if(UART_1_RX_INTERRUPT_ENABLED && (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH))
 106:.\Generated_Source\PSoC5/UART_1.c ****             /* Set the RX Interrupt. */
 107:.\Generated_Source\PSoC5/UART_1.c ****             (void)CyIntSetVector(UART_1_RX_VECT_NUM, &UART_1_RXISR);
 108:.\Generated_Source\PSoC5/UART_1.c ****             CyIntSetPriority(UART_1_RX_VECT_NUM, UART_1_RX_PRIOR_NUM);
 109:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 110:.\Generated_Source\PSoC5/UART_1.c **** 
 111:.\Generated_Source\PSoC5/UART_1.c ****         #if (UART_1_RXHW_ADDRESS_ENABLED)
 112:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_SetRxAddressMode(UART_1_RXAddressMode);
 113:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_SetRxAddress1(UART_1_RXHWADDRESS1);
 114:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_SetRxAddress2(UART_1_RXHWADDRESS2);
 115:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
 116:.\Generated_Source\PSoC5/UART_1.c **** 
 117:.\Generated_Source\PSoC5/UART_1.c ****         /* Init Count7 period */
 118:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXBITCTR_PERIOD_REG = UART_1_RXBITCTR_INIT;
 119:.\Generated_Source\PSoC5/UART_1.c ****         /* Configure the Initial RX interrupt mask */
 120:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXSTATUS_MASK_REG  = UART_1_INIT_RX_INTERRUPTS_MASK;
 121:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* End UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 122:.\Generated_Source\PSoC5/UART_1.c **** 
 123:.\Generated_Source\PSoC5/UART_1.c ****     #if(UART_1_TX_ENABLED)
 124:.\Generated_Source\PSoC5/UART_1.c ****         #if(UART_1_TX_INTERRUPT_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
 125:.\Generated_Source\PSoC5/UART_1.c ****             /* Set the TX Interrupt. */
 126:.\Generated_Source\PSoC5/UART_1.c ****             (void)CyIntSetVector(UART_1_TX_VECT_NUM, &UART_1_TXISR);
 127:.\Generated_Source\PSoC5/UART_1.c ****             CyIntSetPriority(UART_1_TX_VECT_NUM, UART_1_TX_PRIOR_NUM);
 128:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_TX_INTERRUPT_ENABLED */
 129:.\Generated_Source\PSoC5/UART_1.c **** 
 130:.\Generated_Source\PSoC5/UART_1.c ****         /* Write Counter Value for TX Bit Clk Generator*/
 131:.\Generated_Source\PSoC5/UART_1.c ****         #if(UART_1_TXCLKGEN_DP)
 132:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_TXBITCLKGEN_CTR_REG = UART_1_BIT_CENTER;
  91              		.loc 1 132 0
  92 0004 46F22853 		movw	r3, #:lower16:1073767720
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 5


  93 0008 C4F20003 		movt	r3, #:upper16:1073767720
  94 000c 4FF00702 		mov	r2, #7
  95 0010 1A70     		strb	r2, [r3, #0]
 133:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_TXBITCLKTX_COMPLETE_REG = (UART_1_NUMBER_OF_DATA_BITS +
  96              		.loc 1 133 0
  97 0012 46F23853 		movw	r3, #:lower16:1073767736
  98 0016 C4F20003 		movt	r3, #:upper16:1073767736
  99 001a 4FF04802 		mov	r2, #72
 100 001e 1A70     		strb	r2, [r3, #0]
 134:.\Generated_Source\PSoC5/UART_1.c ****                         UART_1_NUMBER_OF_START_BIT) * UART_1_OVER_SAMPLE_COUNT;
 135:.\Generated_Source\PSoC5/UART_1.c ****         #else
 136:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_TXBITCTR_PERIOD_REG = ((UART_1_NUMBER_OF_DATA_BITS +
 137:.\Generated_Source\PSoC5/UART_1.c ****                         UART_1_NUMBER_OF_START_BIT) * UART_1_OVER_SAMPLE_8) - 1u;
 138:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_TXCLKGEN_DP */
 139:.\Generated_Source\PSoC5/UART_1.c **** 
 140:.\Generated_Source\PSoC5/UART_1.c ****         /* Configure the Initial TX interrupt mask */
 141:.\Generated_Source\PSoC5/UART_1.c ****         #if(UART_1_TX_INTERRUPT_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
 142:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_TXSTATUS_MASK_REG = UART_1_TX_STS_FIFO_EMPTY;
 143:.\Generated_Source\PSoC5/UART_1.c ****         #else
 144:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_TXSTATUS_MASK_REG = UART_1_INIT_TX_INTERRUPTS_MASK;
 101              		.loc 1 144 0
 102 0020 46F28753 		movw	r3, #:lower16:1073767815
 103 0024 C4F20003 		movt	r3, #:upper16:1073767815
 104 0028 4FF00002 		mov	r2, #0
 105 002c 1A70     		strb	r2, [r3, #0]
 145:.\Generated_Source\PSoC5/UART_1.c ****         #endif /*End UART_1_TX_INTERRUPT_ENABLED*/
 146:.\Generated_Source\PSoC5/UART_1.c **** 
 147:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* End UART_1_TX_ENABLED */
 148:.\Generated_Source\PSoC5/UART_1.c **** 
 149:.\Generated_Source\PSoC5/UART_1.c ****     #if(UART_1_PARITY_TYPE_SW)  /* Write Parity to Control Register */
 150:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_WriteControlRegister( \
 151:.\Generated_Source\PSoC5/UART_1.c ****             (UART_1_ReadControlRegister() & (uint8)~UART_1_CTRL_PARITY_TYPE_MASK) | \
 152:.\Generated_Source\PSoC5/UART_1.c ****             (uint8)(UART_1_PARITY_TYPE << UART_1_CTRL_PARITY_TYPE0_SHIFT) );
 153:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* End UART_1_PARITY_TYPE_SW */
 154:.\Generated_Source\PSoC5/UART_1.c **** }
 106              		.loc 1 154 0
 107 002e BD46     		mov	sp, r7
 108 0030 80BC     		pop	{r7}
 109 0032 7047     		bx	lr
 110              		.cfi_endproc
 111              	.LFE1:
 112              		.size	UART_1_Init, .-UART_1_Init
 113              		.section	.text.UART_1_Enable,"ax",%progbits
 114              		.align	2
 115              		.global	UART_1_Enable
 116              		.thumb
 117              		.thumb_func
 118              		.type	UART_1_Enable, %function
 119              	UART_1_Enable:
 120              	.LFB2:
 155:.\Generated_Source\PSoC5/UART_1.c **** 
 156:.\Generated_Source\PSoC5/UART_1.c **** 
 157:.\Generated_Source\PSoC5/UART_1.c **** /*******************************************************************************
 158:.\Generated_Source\PSoC5/UART_1.c **** * Function Name: UART_1_Enable
 159:.\Generated_Source\PSoC5/UART_1.c **** ********************************************************************************
 160:.\Generated_Source\PSoC5/UART_1.c **** *
 161:.\Generated_Source\PSoC5/UART_1.c **** * Summary:
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 6


 162:.\Generated_Source\PSoC5/UART_1.c **** *  Enables the UART block operation
 163:.\Generated_Source\PSoC5/UART_1.c **** *
 164:.\Generated_Source\PSoC5/UART_1.c **** * Parameters:
 165:.\Generated_Source\PSoC5/UART_1.c **** *  None.
 166:.\Generated_Source\PSoC5/UART_1.c **** *
 167:.\Generated_Source\PSoC5/UART_1.c **** * Return:
 168:.\Generated_Source\PSoC5/UART_1.c **** *  None.
 169:.\Generated_Source\PSoC5/UART_1.c **** *
 170:.\Generated_Source\PSoC5/UART_1.c **** * Global Variables:
 171:.\Generated_Source\PSoC5/UART_1.c **** *  UART_1_rxAddressDetected - set to initial state (0).
 172:.\Generated_Source\PSoC5/UART_1.c **** *
 173:.\Generated_Source\PSoC5/UART_1.c **** *******************************************************************************/
 174:.\Generated_Source\PSoC5/UART_1.c **** void UART_1_Enable(void) 
 175:.\Generated_Source\PSoC5/UART_1.c **** {
 121              		.loc 1 175 0
 122              		.cfi_startproc
 123              		@ args = 0, pretend = 0, frame = 8
 124              		@ frame_needed = 1, uses_anonymous_args = 0
 125 0000 80B5     		push	{r7, lr}
 126              	.LCFI4:
 127              		.cfi_def_cfa_offset 8
 128 0002 82B0     		sub	sp, sp, #8
 129              	.LCFI5:
 130              		.cfi_def_cfa_offset 16
 131 0004 00AF     		add	r7, sp, #0
 132              		.cfi_offset 14, -4
 133              		.cfi_offset 7, -8
 134              	.LCFI6:
 135              		.cfi_def_cfa_register 7
 176:.\Generated_Source\PSoC5/UART_1.c ****     uint8 enableInterrupts;
 177:.\Generated_Source\PSoC5/UART_1.c ****     enableInterrupts = CyEnterCriticalSection();
 136              		.loc 1 177 0
 137 0006 FFF7FEFF 		bl	CyEnterCriticalSection
 138 000a 0346     		mov	r3, r0
 139 000c FB71     		strb	r3, [r7, #7]
 178:.\Generated_Source\PSoC5/UART_1.c **** 
 179:.\Generated_Source\PSoC5/UART_1.c ****     #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 180:.\Generated_Source\PSoC5/UART_1.c ****         /*RX Counter (Count7) Enable */
 181:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXBITCTR_CONTROL_REG |= UART_1_CNTR_ENABLE;
 182:.\Generated_Source\PSoC5/UART_1.c ****         /* Enable the RX Interrupt. */
 183:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXSTATUS_ACTL_REG  |= UART_1_INT_ENABLE;
 184:.\Generated_Source\PSoC5/UART_1.c ****         #if(UART_1_RX_INTERRUPT_ENABLED && (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH))
 185:.\Generated_Source\PSoC5/UART_1.c ****             CyIntEnable(UART_1_RX_VECT_NUM);
 186:.\Generated_Source\PSoC5/UART_1.c ****             #if (UART_1_RXHW_ADDRESS_ENABLED)
 187:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_rxAddressDetected = 0u;
 188:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
 189:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 190:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* End UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 191:.\Generated_Source\PSoC5/UART_1.c **** 
 192:.\Generated_Source\PSoC5/UART_1.c ****     #if(UART_1_TX_ENABLED)
 193:.\Generated_Source\PSoC5/UART_1.c ****         /*TX Counter (DP/Count7) Enable */
 194:.\Generated_Source\PSoC5/UART_1.c ****         #if(!UART_1_TXCLKGEN_DP)
 195:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_TXBITCTR_CONTROL_REG |= UART_1_CNTR_ENABLE;
 196:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_TXCLKGEN_DP */
 197:.\Generated_Source\PSoC5/UART_1.c ****         /* Enable the TX Interrupt. */
 198:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_TXSTATUS_ACTL_REG |= UART_1_INT_ENABLE;
 140              		.loc 1 198 0
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 7


 141 000e 46F29753 		movw	r3, #:lower16:1073767831
 142 0012 C4F20003 		movt	r3, #:upper16:1073767831
 143 0016 46F29752 		movw	r2, #:lower16:1073767831
 144 001a C4F20002 		movt	r2, #:upper16:1073767831
 145 001e 1278     		ldrb	r2, [r2, #0]
 146 0020 D2B2     		uxtb	r2, r2
 147 0022 42F01002 		orr	r2, r2, #16
 148 0026 D2B2     		uxtb	r2, r2
 149 0028 1A70     		strb	r2, [r3, #0]
 199:.\Generated_Source\PSoC5/UART_1.c ****         #if(UART_1_TX_INTERRUPT_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
 200:.\Generated_Source\PSoC5/UART_1.c ****             CyIntEnable(UART_1_TX_VECT_NUM);
 201:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_TX_INTERRUPT_ENABLED*/
 202:.\Generated_Source\PSoC5/UART_1.c ****      #endif /* End UART_1_TX_ENABLED */
 203:.\Generated_Source\PSoC5/UART_1.c **** 
 204:.\Generated_Source\PSoC5/UART_1.c ****     #if(UART_1_INTERNAL_CLOCK_USED)
 205:.\Generated_Source\PSoC5/UART_1.c ****         /* Enable the clock. */
 206:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_IntClock_Start();
 150              		.loc 1 206 0
 151 002a FFF7FEFF 		bl	UART_1_IntClock_Start
 207:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* End UART_1_INTERNAL_CLOCK_USED */
 208:.\Generated_Source\PSoC5/UART_1.c **** 
 209:.\Generated_Source\PSoC5/UART_1.c ****     CyExitCriticalSection(enableInterrupts);
 152              		.loc 1 209 0
 153 002e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 154 0030 1846     		mov	r0, r3
 155 0032 FFF7FEFF 		bl	CyExitCriticalSection
 210:.\Generated_Source\PSoC5/UART_1.c **** }
 156              		.loc 1 210 0
 157 0036 07F10807 		add	r7, r7, #8
 158 003a BD46     		mov	sp, r7
 159 003c 80BD     		pop	{r7, pc}
 160              		.cfi_endproc
 161              	.LFE2:
 162              		.size	UART_1_Enable, .-UART_1_Enable
 163 003e 00BF     		.section	.text.UART_1_Stop,"ax",%progbits
 164              		.align	2
 165              		.global	UART_1_Stop
 166              		.thumb
 167              		.thumb_func
 168              		.type	UART_1_Stop, %function
 169              	UART_1_Stop:
 170              	.LFB3:
 211:.\Generated_Source\PSoC5/UART_1.c **** 
 212:.\Generated_Source\PSoC5/UART_1.c **** 
 213:.\Generated_Source\PSoC5/UART_1.c **** /*******************************************************************************
 214:.\Generated_Source\PSoC5/UART_1.c **** * Function Name: UART_1_Stop
 215:.\Generated_Source\PSoC5/UART_1.c **** ********************************************************************************
 216:.\Generated_Source\PSoC5/UART_1.c **** *
 217:.\Generated_Source\PSoC5/UART_1.c **** * Summary:
 218:.\Generated_Source\PSoC5/UART_1.c **** *  Disable the UART component
 219:.\Generated_Source\PSoC5/UART_1.c **** *
 220:.\Generated_Source\PSoC5/UART_1.c **** * Parameters:
 221:.\Generated_Source\PSoC5/UART_1.c **** *  None.
 222:.\Generated_Source\PSoC5/UART_1.c **** *
 223:.\Generated_Source\PSoC5/UART_1.c **** * Return:
 224:.\Generated_Source\PSoC5/UART_1.c **** *  None.
 225:.\Generated_Source\PSoC5/UART_1.c **** *
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 8


 226:.\Generated_Source\PSoC5/UART_1.c **** *******************************************************************************/
 227:.\Generated_Source\PSoC5/UART_1.c **** void UART_1_Stop(void) 
 228:.\Generated_Source\PSoC5/UART_1.c **** {
 171              		.loc 1 228 0
 172              		.cfi_startproc
 173              		@ args = 0, pretend = 0, frame = 8
 174              		@ frame_needed = 1, uses_anonymous_args = 0
 175 0000 80B5     		push	{r7, lr}
 176              	.LCFI7:
 177              		.cfi_def_cfa_offset 8
 178 0002 82B0     		sub	sp, sp, #8
 179              	.LCFI8:
 180              		.cfi_def_cfa_offset 16
 181 0004 00AF     		add	r7, sp, #0
 182              		.cfi_offset 14, -4
 183              		.cfi_offset 7, -8
 184              	.LCFI9:
 185              		.cfi_def_cfa_register 7
 229:.\Generated_Source\PSoC5/UART_1.c ****     uint8 enableInterrupts;
 230:.\Generated_Source\PSoC5/UART_1.c ****     enableInterrupts = CyEnterCriticalSection();
 186              		.loc 1 230 0
 187 0006 FFF7FEFF 		bl	CyEnterCriticalSection
 188 000a 0346     		mov	r3, r0
 189 000c FB71     		strb	r3, [r7, #7]
 231:.\Generated_Source\PSoC5/UART_1.c **** 
 232:.\Generated_Source\PSoC5/UART_1.c ****     /* Write Bit Counter Disable */
 233:.\Generated_Source\PSoC5/UART_1.c ****     #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 234:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXBITCTR_CONTROL_REG &= (uint8)~UART_1_CNTR_ENABLE;
 235:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* End UART_1_RX_ENABLED */
 236:.\Generated_Source\PSoC5/UART_1.c **** 
 237:.\Generated_Source\PSoC5/UART_1.c ****     #if(UART_1_TX_ENABLED)
 238:.\Generated_Source\PSoC5/UART_1.c ****         #if(!UART_1_TXCLKGEN_DP)
 239:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_TXBITCTR_CONTROL_REG &= (uint8)~UART_1_CNTR_ENABLE;
 240:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_TXCLKGEN_DP */
 241:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* UART_1_TX_ENABLED */
 242:.\Generated_Source\PSoC5/UART_1.c **** 
 243:.\Generated_Source\PSoC5/UART_1.c ****     #if(UART_1_INTERNAL_CLOCK_USED)
 244:.\Generated_Source\PSoC5/UART_1.c ****         /* Disable the clock. */
 245:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_IntClock_Stop();
 190              		.loc 1 245 0
 191 000e FFF7FEFF 		bl	UART_1_IntClock_Stop
 246:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* End UART_1_INTERNAL_CLOCK_USED */
 247:.\Generated_Source\PSoC5/UART_1.c **** 
 248:.\Generated_Source\PSoC5/UART_1.c ****     /* Disable internal interrupt component */
 249:.\Generated_Source\PSoC5/UART_1.c ****     #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 250:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXSTATUS_ACTL_REG  &= (uint8)~UART_1_INT_ENABLE;
 251:.\Generated_Source\PSoC5/UART_1.c ****         #if(UART_1_RX_INTERRUPT_ENABLED && (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH))
 252:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_DisableRxInt();
 253:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 254:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* End UART_1_RX_ENABLED */
 255:.\Generated_Source\PSoC5/UART_1.c **** 
 256:.\Generated_Source\PSoC5/UART_1.c ****     #if(UART_1_TX_ENABLED)
 257:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_TXSTATUS_ACTL_REG &= (uint8)~UART_1_INT_ENABLE;
 192              		.loc 1 257 0
 193 0012 46F29753 		movw	r3, #:lower16:1073767831
 194 0016 C4F20003 		movt	r3, #:upper16:1073767831
 195 001a 46F29752 		movw	r2, #:lower16:1073767831
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 9


 196 001e C4F20002 		movt	r2, #:upper16:1073767831
 197 0022 1278     		ldrb	r2, [r2, #0]
 198 0024 D2B2     		uxtb	r2, r2
 199 0026 02F0EF02 		and	r2, r2, #239
 200 002a 1A70     		strb	r2, [r3, #0]
 258:.\Generated_Source\PSoC5/UART_1.c ****         #if(UART_1_TX_INTERRUPT_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
 259:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_DisableTxInt();
 260:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_TX_INTERRUPT_ENABLED */
 261:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* End UART_1_TX_ENABLED */
 262:.\Generated_Source\PSoC5/UART_1.c **** 
 263:.\Generated_Source\PSoC5/UART_1.c ****     CyExitCriticalSection(enableInterrupts);
 201              		.loc 1 263 0
 202 002c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 203 002e 1846     		mov	r0, r3
 204 0030 FFF7FEFF 		bl	CyExitCriticalSection
 264:.\Generated_Source\PSoC5/UART_1.c **** }
 205              		.loc 1 264 0
 206 0034 07F10807 		add	r7, r7, #8
 207 0038 BD46     		mov	sp, r7
 208 003a 80BD     		pop	{r7, pc}
 209              		.cfi_endproc
 210              	.LFE3:
 211              		.size	UART_1_Stop, .-UART_1_Stop
 212              		.section	.text.UART_1_ReadControlRegister,"ax",%progbits
 213              		.align	2
 214              		.global	UART_1_ReadControlRegister
 215              		.thumb
 216              		.thumb_func
 217              		.type	UART_1_ReadControlRegister, %function
 218              	UART_1_ReadControlRegister:
 219              	.LFB4:
 265:.\Generated_Source\PSoC5/UART_1.c **** 
 266:.\Generated_Source\PSoC5/UART_1.c **** 
 267:.\Generated_Source\PSoC5/UART_1.c **** /*******************************************************************************
 268:.\Generated_Source\PSoC5/UART_1.c **** * Function Name: UART_1_ReadControlRegister
 269:.\Generated_Source\PSoC5/UART_1.c **** ********************************************************************************
 270:.\Generated_Source\PSoC5/UART_1.c **** *
 271:.\Generated_Source\PSoC5/UART_1.c **** * Summary:
 272:.\Generated_Source\PSoC5/UART_1.c **** *  Read the current state of the control register
 273:.\Generated_Source\PSoC5/UART_1.c **** *
 274:.\Generated_Source\PSoC5/UART_1.c **** * Parameters:
 275:.\Generated_Source\PSoC5/UART_1.c **** *  None.
 276:.\Generated_Source\PSoC5/UART_1.c **** *
 277:.\Generated_Source\PSoC5/UART_1.c **** * Return:
 278:.\Generated_Source\PSoC5/UART_1.c **** *  Current state of the control register.
 279:.\Generated_Source\PSoC5/UART_1.c **** *
 280:.\Generated_Source\PSoC5/UART_1.c **** *******************************************************************************/
 281:.\Generated_Source\PSoC5/UART_1.c **** uint8 UART_1_ReadControlRegister(void) 
 282:.\Generated_Source\PSoC5/UART_1.c **** {
 220              		.loc 1 282 0
 221              		.cfi_startproc
 222              		@ args = 0, pretend = 0, frame = 0
 223              		@ frame_needed = 1, uses_anonymous_args = 0
 224              		@ link register save eliminated.
 225 0000 80B4     		push	{r7}
 226              	.LCFI10:
 227              		.cfi_def_cfa_offset 4
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 10


 228 0002 00AF     		add	r7, sp, #0
 229              		.cfi_offset 7, -4
 230              	.LCFI11:
 231              		.cfi_def_cfa_register 7
 283:.\Generated_Source\PSoC5/UART_1.c ****     #if( UART_1_CONTROL_REG_REMOVED )
 284:.\Generated_Source\PSoC5/UART_1.c ****         return(0u);
 232              		.loc 1 284 0
 233 0004 4FF00003 		mov	r3, #0
 285:.\Generated_Source\PSoC5/UART_1.c ****     #else
 286:.\Generated_Source\PSoC5/UART_1.c ****         return(UART_1_CONTROL_REG);
 287:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* End UART_1_CONTROL_REG_REMOVED */
 288:.\Generated_Source\PSoC5/UART_1.c **** }
 234              		.loc 1 288 0
 235 0008 1846     		mov	r0, r3
 236 000a BD46     		mov	sp, r7
 237 000c 80BC     		pop	{r7}
 238 000e 7047     		bx	lr
 239              		.cfi_endproc
 240              	.LFE4:
 241              		.size	UART_1_ReadControlRegister, .-UART_1_ReadControlRegister
 242              		.section	.text.UART_1_WriteControlRegister,"ax",%progbits
 243              		.align	2
 244              		.global	UART_1_WriteControlRegister
 245              		.thumb
 246              		.thumb_func
 247              		.type	UART_1_WriteControlRegister, %function
 248              	UART_1_WriteControlRegister:
 249              	.LFB5:
 289:.\Generated_Source\PSoC5/UART_1.c **** 
 290:.\Generated_Source\PSoC5/UART_1.c **** 
 291:.\Generated_Source\PSoC5/UART_1.c **** /*******************************************************************************
 292:.\Generated_Source\PSoC5/UART_1.c **** * Function Name: UART_1_WriteControlRegister
 293:.\Generated_Source\PSoC5/UART_1.c **** ********************************************************************************
 294:.\Generated_Source\PSoC5/UART_1.c **** *
 295:.\Generated_Source\PSoC5/UART_1.c **** * Summary:
 296:.\Generated_Source\PSoC5/UART_1.c **** *  Writes an 8-bit value into the control register
 297:.\Generated_Source\PSoC5/UART_1.c **** *
 298:.\Generated_Source\PSoC5/UART_1.c **** * Parameters:
 299:.\Generated_Source\PSoC5/UART_1.c **** *  control:  control register value
 300:.\Generated_Source\PSoC5/UART_1.c **** *
 301:.\Generated_Source\PSoC5/UART_1.c **** * Return:
 302:.\Generated_Source\PSoC5/UART_1.c **** *  None.
 303:.\Generated_Source\PSoC5/UART_1.c **** *
 304:.\Generated_Source\PSoC5/UART_1.c **** *******************************************************************************/
 305:.\Generated_Source\PSoC5/UART_1.c **** void  UART_1_WriteControlRegister(uint8 control) 
 306:.\Generated_Source\PSoC5/UART_1.c **** {
 250              		.loc 1 306 0
 251              		.cfi_startproc
 252              		@ args = 0, pretend = 0, frame = 8
 253              		@ frame_needed = 1, uses_anonymous_args = 0
 254              		@ link register save eliminated.
 255 0000 80B4     		push	{r7}
 256              	.LCFI12:
 257              		.cfi_def_cfa_offset 4
 258 0002 83B0     		sub	sp, sp, #12
 259              	.LCFI13:
 260              		.cfi_def_cfa_offset 16
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 11


 261 0004 00AF     		add	r7, sp, #0
 262              		.cfi_offset 7, -4
 263              	.LCFI14:
 264              		.cfi_def_cfa_register 7
 265 0006 0346     		mov	r3, r0
 266 0008 FB71     		strb	r3, [r7, #7]
 307:.\Generated_Source\PSoC5/UART_1.c ****     #if( UART_1_CONTROL_REG_REMOVED )
 308:.\Generated_Source\PSoC5/UART_1.c ****         if(control != 0u) { }      /* release compiler warning */
 309:.\Generated_Source\PSoC5/UART_1.c ****     #else
 310:.\Generated_Source\PSoC5/UART_1.c ****        UART_1_CONTROL_REG = control;
 311:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* End UART_1_CONTROL_REG_REMOVED */
 312:.\Generated_Source\PSoC5/UART_1.c **** }
 267              		.loc 1 312 0
 268 000a 07F10C07 		add	r7, r7, #12
 269 000e BD46     		mov	sp, r7
 270 0010 80BC     		pop	{r7}
 271 0012 7047     		bx	lr
 272              		.cfi_endproc
 273              	.LFE5:
 274              		.size	UART_1_WriteControlRegister, .-UART_1_WriteControlRegister
 275              		.section	.text.UART_1_SetTxInterruptMode,"ax",%progbits
 276              		.align	2
 277              		.global	UART_1_SetTxInterruptMode
 278              		.thumb
 279              		.thumb_func
 280              		.type	UART_1_SetTxInterruptMode, %function
 281              	UART_1_SetTxInterruptMode:
 282              	.LFB6:
 313:.\Generated_Source\PSoC5/UART_1.c **** 
 314:.\Generated_Source\PSoC5/UART_1.c **** 
 315:.\Generated_Source\PSoC5/UART_1.c **** #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 316:.\Generated_Source\PSoC5/UART_1.c **** 
 317:.\Generated_Source\PSoC5/UART_1.c ****     #if(UART_1_RX_INTERRUPT_ENABLED)
 318:.\Generated_Source\PSoC5/UART_1.c **** 
 319:.\Generated_Source\PSoC5/UART_1.c ****         /*******************************************************************************
 320:.\Generated_Source\PSoC5/UART_1.c ****         * Function Name: UART_1_EnableRxInt
 321:.\Generated_Source\PSoC5/UART_1.c ****         ********************************************************************************
 322:.\Generated_Source\PSoC5/UART_1.c ****         *
 323:.\Generated_Source\PSoC5/UART_1.c ****         * Summary:
 324:.\Generated_Source\PSoC5/UART_1.c ****         *  Enable RX interrupt generation
 325:.\Generated_Source\PSoC5/UART_1.c ****         *
 326:.\Generated_Source\PSoC5/UART_1.c ****         * Parameters:
 327:.\Generated_Source\PSoC5/UART_1.c ****         *  None.
 328:.\Generated_Source\PSoC5/UART_1.c ****         *
 329:.\Generated_Source\PSoC5/UART_1.c ****         * Return:
 330:.\Generated_Source\PSoC5/UART_1.c ****         *  None.
 331:.\Generated_Source\PSoC5/UART_1.c ****         *
 332:.\Generated_Source\PSoC5/UART_1.c ****         * Theory:
 333:.\Generated_Source\PSoC5/UART_1.c ****         *  Enable the interrupt output -or- the interrupt component itself
 334:.\Generated_Source\PSoC5/UART_1.c ****         *
 335:.\Generated_Source\PSoC5/UART_1.c ****         *******************************************************************************/
 336:.\Generated_Source\PSoC5/UART_1.c ****         void UART_1_EnableRxInt(void) 
 337:.\Generated_Source\PSoC5/UART_1.c ****         {
 338:.\Generated_Source\PSoC5/UART_1.c ****             CyIntEnable(UART_1_RX_VECT_NUM);
 339:.\Generated_Source\PSoC5/UART_1.c ****         }
 340:.\Generated_Source\PSoC5/UART_1.c **** 
 341:.\Generated_Source\PSoC5/UART_1.c **** 
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 12


 342:.\Generated_Source\PSoC5/UART_1.c ****         /*******************************************************************************
 343:.\Generated_Source\PSoC5/UART_1.c ****         * Function Name: UART_1_DisableRxInt
 344:.\Generated_Source\PSoC5/UART_1.c ****         ********************************************************************************
 345:.\Generated_Source\PSoC5/UART_1.c ****         *
 346:.\Generated_Source\PSoC5/UART_1.c ****         * Summary:
 347:.\Generated_Source\PSoC5/UART_1.c ****         *  Disable RX interrupt generation
 348:.\Generated_Source\PSoC5/UART_1.c ****         *
 349:.\Generated_Source\PSoC5/UART_1.c ****         * Parameters:
 350:.\Generated_Source\PSoC5/UART_1.c ****         *  None.
 351:.\Generated_Source\PSoC5/UART_1.c ****         *
 352:.\Generated_Source\PSoC5/UART_1.c ****         * Return:
 353:.\Generated_Source\PSoC5/UART_1.c ****         *  None.
 354:.\Generated_Source\PSoC5/UART_1.c ****         *
 355:.\Generated_Source\PSoC5/UART_1.c ****         * Theory:
 356:.\Generated_Source\PSoC5/UART_1.c ****         *  Disable the interrupt output -or- the interrupt component itself
 357:.\Generated_Source\PSoC5/UART_1.c ****         *
 358:.\Generated_Source\PSoC5/UART_1.c ****         *******************************************************************************/
 359:.\Generated_Source\PSoC5/UART_1.c ****         void UART_1_DisableRxInt(void) 
 360:.\Generated_Source\PSoC5/UART_1.c ****         {
 361:.\Generated_Source\PSoC5/UART_1.c ****             CyIntDisable(UART_1_RX_VECT_NUM);
 362:.\Generated_Source\PSoC5/UART_1.c ****         }
 363:.\Generated_Source\PSoC5/UART_1.c **** 
 364:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* UART_1_RX_INTERRUPT_ENABLED */
 365:.\Generated_Source\PSoC5/UART_1.c **** 
 366:.\Generated_Source\PSoC5/UART_1.c **** 
 367:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 368:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_SetRxInterruptMode
 369:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 370:.\Generated_Source\PSoC5/UART_1.c ****     *
 371:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 372:.\Generated_Source\PSoC5/UART_1.c ****     *  Configure which status bits trigger an interrupt event
 373:.\Generated_Source\PSoC5/UART_1.c ****     *
 374:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 375:.\Generated_Source\PSoC5/UART_1.c ****     *  IntSrc:  An or'd combination of the desired status bit masks (defined in
 376:.\Generated_Source\PSoC5/UART_1.c ****     *           the header file)
 377:.\Generated_Source\PSoC5/UART_1.c ****     *
 378:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 379:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 380:.\Generated_Source\PSoC5/UART_1.c ****     *
 381:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
 382:.\Generated_Source\PSoC5/UART_1.c ****     *  Enables the output of specific status bits to the interrupt controller
 383:.\Generated_Source\PSoC5/UART_1.c ****     *
 384:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 385:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_SetRxInterruptMode(uint8 intSrc) 
 386:.\Generated_Source\PSoC5/UART_1.c ****     {
 387:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXSTATUS_MASK_REG  = intSrc;
 388:.\Generated_Source\PSoC5/UART_1.c ****     }
 389:.\Generated_Source\PSoC5/UART_1.c **** 
 390:.\Generated_Source\PSoC5/UART_1.c **** 
 391:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 392:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_ReadRxData
 393:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 394:.\Generated_Source\PSoC5/UART_1.c ****     *
 395:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 396:.\Generated_Source\PSoC5/UART_1.c ****     *  Returns data in RX Data register without checking status register to
 397:.\Generated_Source\PSoC5/UART_1.c ****     *  determine if data is valid
 398:.\Generated_Source\PSoC5/UART_1.c ****     *
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 13


 399:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 400:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 401:.\Generated_Source\PSoC5/UART_1.c ****     *
 402:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 403:.\Generated_Source\PSoC5/UART_1.c ****     *  Received data from RX register
 404:.\Generated_Source\PSoC5/UART_1.c ****     *
 405:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
 406:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBuffer - RAM buffer pointer for save received data.
 407:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferWrite - cyclic index for write to rxBuffer,
 408:.\Generated_Source\PSoC5/UART_1.c ****     *     checked to identify new data.
 409:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferRead - cyclic index for read from rxBuffer,
 410:.\Generated_Source\PSoC5/UART_1.c ****     *     incremented after each byte has been read from buffer.
 411:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferLoopDetect - creared if loop condition was detected
 412:.\Generated_Source\PSoC5/UART_1.c ****     *     in RX ISR.
 413:.\Generated_Source\PSoC5/UART_1.c ****     *
 414:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
 415:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
 416:.\Generated_Source\PSoC5/UART_1.c ****     *
 417:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 418:.\Generated_Source\PSoC5/UART_1.c ****     uint8 UART_1_ReadRxData(void) 
 419:.\Generated_Source\PSoC5/UART_1.c ****     {
 420:.\Generated_Source\PSoC5/UART_1.c ****         uint8 rxData;
 421:.\Generated_Source\PSoC5/UART_1.c **** 
 422:.\Generated_Source\PSoC5/UART_1.c ****         #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
 423:.\Generated_Source\PSoC5/UART_1.c ****             uint8 loc_rxBufferRead;
 424:.\Generated_Source\PSoC5/UART_1.c ****             uint8 loc_rxBufferWrite;
 425:.\Generated_Source\PSoC5/UART_1.c ****             /* Protect variables that could change on interrupt. */
 426:.\Generated_Source\PSoC5/UART_1.c ****             /* Disable Rx interrupt. */
 427:.\Generated_Source\PSoC5/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 428:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_DisableRxInt();
 429:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* UART_1_RX_INTERRUPT_ENABLED */
 430:.\Generated_Source\PSoC5/UART_1.c ****             loc_rxBufferRead = UART_1_rxBufferRead;
 431:.\Generated_Source\PSoC5/UART_1.c ****             loc_rxBufferWrite = UART_1_rxBufferWrite;
 432:.\Generated_Source\PSoC5/UART_1.c **** 
 433:.\Generated_Source\PSoC5/UART_1.c ****             if( (UART_1_rxBufferLoopDetect != 0u) || (loc_rxBufferRead != loc_rxBufferWrite) )
 434:.\Generated_Source\PSoC5/UART_1.c ****             {
 435:.\Generated_Source\PSoC5/UART_1.c ****                 rxData = UART_1_rxBuffer[loc_rxBufferRead];
 436:.\Generated_Source\PSoC5/UART_1.c ****                 loc_rxBufferRead++;
 437:.\Generated_Source\PSoC5/UART_1.c **** 
 438:.\Generated_Source\PSoC5/UART_1.c ****                 if(loc_rxBufferRead >= UART_1_RXBUFFERSIZE)
 439:.\Generated_Source\PSoC5/UART_1.c ****                 {
 440:.\Generated_Source\PSoC5/UART_1.c ****                     loc_rxBufferRead = 0u;
 441:.\Generated_Source\PSoC5/UART_1.c ****                 }
 442:.\Generated_Source\PSoC5/UART_1.c ****                 /* Update the real pointer */
 443:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_rxBufferRead = loc_rxBufferRead;
 444:.\Generated_Source\PSoC5/UART_1.c **** 
 445:.\Generated_Source\PSoC5/UART_1.c ****                 if(UART_1_rxBufferLoopDetect != 0u )
 446:.\Generated_Source\PSoC5/UART_1.c ****                 {
 447:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_rxBufferLoopDetect = 0u;
 448:.\Generated_Source\PSoC5/UART_1.c ****                     #if( (UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u) && \
 449:.\Generated_Source\PSoC5/UART_1.c ****                          (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH) )
 450:.\Generated_Source\PSoC5/UART_1.c ****                         /* When Hardware Flow Control selected - return RX mask */
 451:.\Generated_Source\PSoC5/UART_1.c ****                         #if( UART_1_HD_ENABLED )
 452:.\Generated_Source\PSoC5/UART_1.c ****                             if((UART_1_CONTROL_REG & UART_1_CTRL_HD_SEND) == 0u)
 453:.\Generated_Source\PSoC5/UART_1.c ****                             {   /* In Half duplex mode return RX mask only in RX
 454:.\Generated_Source\PSoC5/UART_1.c ****                                 *  configuration set, otherwise
 455:.\Generated_Source\PSoC5/UART_1.c ****                                 *  mask will be returned in LoadRxConfig() API.
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 14


 456:.\Generated_Source\PSoC5/UART_1.c ****                                 */
 457:.\Generated_Source\PSoC5/UART_1.c ****                                 UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 458:.\Generated_Source\PSoC5/UART_1.c ****                             }
 459:.\Generated_Source\PSoC5/UART_1.c ****                         #else
 460:.\Generated_Source\PSoC5/UART_1.c ****                             UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 461:.\Generated_Source\PSoC5/UART_1.c ****                         #endif /* end UART_1_HD_ENABLED */
 462:.\Generated_Source\PSoC5/UART_1.c ****                     #endif /* UART_1_RX_INTERRUPT_ENABLED and Hardware flow control*/
 463:.\Generated_Source\PSoC5/UART_1.c ****                 }
 464:.\Generated_Source\PSoC5/UART_1.c ****             }
 465:.\Generated_Source\PSoC5/UART_1.c ****             else
 466:.\Generated_Source\PSoC5/UART_1.c ****             {   /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit*/
 467:.\Generated_Source\PSoC5/UART_1.c ****                 rxData = UART_1_RXDATA_REG;
 468:.\Generated_Source\PSoC5/UART_1.c ****             }
 469:.\Generated_Source\PSoC5/UART_1.c **** 
 470:.\Generated_Source\PSoC5/UART_1.c ****             /* Enable Rx interrupt. */
 471:.\Generated_Source\PSoC5/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 472:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_EnableRxInt();
 473:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 474:.\Generated_Source\PSoC5/UART_1.c **** 
 475:.\Generated_Source\PSoC5/UART_1.c ****         #else /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 476:.\Generated_Source\PSoC5/UART_1.c **** 
 477:.\Generated_Source\PSoC5/UART_1.c ****             /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit*/
 478:.\Generated_Source\PSoC5/UART_1.c ****             rxData = UART_1_RXDATA_REG;
 479:.\Generated_Source\PSoC5/UART_1.c **** 
 480:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 481:.\Generated_Source\PSoC5/UART_1.c **** 
 482:.\Generated_Source\PSoC5/UART_1.c ****         return(rxData);
 483:.\Generated_Source\PSoC5/UART_1.c ****     }
 484:.\Generated_Source\PSoC5/UART_1.c **** 
 485:.\Generated_Source\PSoC5/UART_1.c **** 
 486:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 487:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_ReadRxStatus
 488:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 489:.\Generated_Source\PSoC5/UART_1.c ****     *
 490:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 491:.\Generated_Source\PSoC5/UART_1.c ****     *  Read the current state of the status register
 492:.\Generated_Source\PSoC5/UART_1.c ****     *  And detect software buffer overflow.
 493:.\Generated_Source\PSoC5/UART_1.c ****     *
 494:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 495:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 496:.\Generated_Source\PSoC5/UART_1.c ****     *
 497:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 498:.\Generated_Source\PSoC5/UART_1.c ****     *  Current state of the status register.
 499:.\Generated_Source\PSoC5/UART_1.c ****     *
 500:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
 501:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferOverflow - used to indicate overload condition.
 502:.\Generated_Source\PSoC5/UART_1.c ****     *   It set to one in RX interrupt when there isn?t free space in
 503:.\Generated_Source\PSoC5/UART_1.c ****     *   UART_1_rxBufferRead to write new data. This condition returned
 504:.\Generated_Source\PSoC5/UART_1.c ****     *   and cleared to zero by this API as an
 505:.\Generated_Source\PSoC5/UART_1.c ****     *   UART_1_RX_STS_SOFT_BUFF_OVER bit along with RX Status register
 506:.\Generated_Source\PSoC5/UART_1.c ****     *   bits.
 507:.\Generated_Source\PSoC5/UART_1.c ****     *
 508:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 509:.\Generated_Source\PSoC5/UART_1.c ****     uint8 UART_1_ReadRxStatus(void) 
 510:.\Generated_Source\PSoC5/UART_1.c ****     {
 511:.\Generated_Source\PSoC5/UART_1.c ****         uint8 status;
 512:.\Generated_Source\PSoC5/UART_1.c **** 
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 15


 513:.\Generated_Source\PSoC5/UART_1.c ****         status = UART_1_RXSTATUS_REG & UART_1_RX_HW_MASK;
 514:.\Generated_Source\PSoC5/UART_1.c **** 
 515:.\Generated_Source\PSoC5/UART_1.c ****         #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
 516:.\Generated_Source\PSoC5/UART_1.c ****             if( UART_1_rxBufferOverflow != 0u )
 517:.\Generated_Source\PSoC5/UART_1.c ****             {
 518:.\Generated_Source\PSoC5/UART_1.c ****                 status |= UART_1_RX_STS_SOFT_BUFF_OVER;
 519:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_rxBufferOverflow = 0u;
 520:.\Generated_Source\PSoC5/UART_1.c ****             }
 521:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* UART_1_RXBUFFERSIZE */
 522:.\Generated_Source\PSoC5/UART_1.c **** 
 523:.\Generated_Source\PSoC5/UART_1.c ****         return(status);
 524:.\Generated_Source\PSoC5/UART_1.c ****     }
 525:.\Generated_Source\PSoC5/UART_1.c **** 
 526:.\Generated_Source\PSoC5/UART_1.c **** 
 527:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 528:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_GetChar
 529:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 530:.\Generated_Source\PSoC5/UART_1.c ****     *
 531:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 532:.\Generated_Source\PSoC5/UART_1.c ****     *  Reads UART RX buffer immediately, if data is not available or an error
 533:.\Generated_Source\PSoC5/UART_1.c ****     *  condition exists, zero is returned; otherwise, character is read and
 534:.\Generated_Source\PSoC5/UART_1.c ****     *  returned.
 535:.\Generated_Source\PSoC5/UART_1.c ****     *
 536:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 537:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 538:.\Generated_Source\PSoC5/UART_1.c ****     *
 539:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 540:.\Generated_Source\PSoC5/UART_1.c ****     *  Character read from UART RX buffer. ASCII characters from 1 to 255 are valid.
 541:.\Generated_Source\PSoC5/UART_1.c ****     *  A returned zero signifies an error condition or no data available.
 542:.\Generated_Source\PSoC5/UART_1.c ****     *
 543:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
 544:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBuffer - RAM buffer pointer for save received data.
 545:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferWrite - cyclic index for write to rxBuffer,
 546:.\Generated_Source\PSoC5/UART_1.c ****     *     checked to identify new data.
 547:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferRead - cyclic index for read from rxBuffer,
 548:.\Generated_Source\PSoC5/UART_1.c ****     *     incremented after each byte has been read from buffer.
 549:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferLoopDetect - creared if loop condition was detected
 550:.\Generated_Source\PSoC5/UART_1.c ****     *     in RX ISR.
 551:.\Generated_Source\PSoC5/UART_1.c ****     *
 552:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
 553:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
 554:.\Generated_Source\PSoC5/UART_1.c ****     *
 555:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 556:.\Generated_Source\PSoC5/UART_1.c ****     uint8 UART_1_GetChar(void) 
 557:.\Generated_Source\PSoC5/UART_1.c ****     {
 558:.\Generated_Source\PSoC5/UART_1.c ****         uint8 rxData = 0u;
 559:.\Generated_Source\PSoC5/UART_1.c ****         uint8 rxStatus;
 560:.\Generated_Source\PSoC5/UART_1.c **** 
 561:.\Generated_Source\PSoC5/UART_1.c ****         #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
 562:.\Generated_Source\PSoC5/UART_1.c ****             uint8 loc_rxBufferRead;
 563:.\Generated_Source\PSoC5/UART_1.c ****             uint8 loc_rxBufferWrite;
 564:.\Generated_Source\PSoC5/UART_1.c ****             /* Protect variables that could change on interrupt. */
 565:.\Generated_Source\PSoC5/UART_1.c ****             /* Disable Rx interrupt. */
 566:.\Generated_Source\PSoC5/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 567:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_DisableRxInt();
 568:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* UART_1_RX_INTERRUPT_ENABLED */
 569:.\Generated_Source\PSoC5/UART_1.c ****             loc_rxBufferRead = UART_1_rxBufferRead;
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 16


 570:.\Generated_Source\PSoC5/UART_1.c ****             loc_rxBufferWrite = UART_1_rxBufferWrite;
 571:.\Generated_Source\PSoC5/UART_1.c **** 
 572:.\Generated_Source\PSoC5/UART_1.c ****             if( (UART_1_rxBufferLoopDetect != 0u) || (loc_rxBufferRead != loc_rxBufferWrite) )
 573:.\Generated_Source\PSoC5/UART_1.c ****             {
 574:.\Generated_Source\PSoC5/UART_1.c ****                 rxData = UART_1_rxBuffer[loc_rxBufferRead];
 575:.\Generated_Source\PSoC5/UART_1.c ****                 loc_rxBufferRead++;
 576:.\Generated_Source\PSoC5/UART_1.c ****                 if(loc_rxBufferRead >= UART_1_RXBUFFERSIZE)
 577:.\Generated_Source\PSoC5/UART_1.c ****                 {
 578:.\Generated_Source\PSoC5/UART_1.c ****                     loc_rxBufferRead = 0u;
 579:.\Generated_Source\PSoC5/UART_1.c ****                 }
 580:.\Generated_Source\PSoC5/UART_1.c ****                 /* Update the real pointer */
 581:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_rxBufferRead = loc_rxBufferRead;
 582:.\Generated_Source\PSoC5/UART_1.c **** 
 583:.\Generated_Source\PSoC5/UART_1.c ****                 if(UART_1_rxBufferLoopDetect > 0u )
 584:.\Generated_Source\PSoC5/UART_1.c ****                 {
 585:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_rxBufferLoopDetect = 0u;
 586:.\Generated_Source\PSoC5/UART_1.c ****                     #if( (UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u) )
 587:.\Generated_Source\PSoC5/UART_1.c ****                         /* When Hardware Flow Control selected - return RX mask */
 588:.\Generated_Source\PSoC5/UART_1.c ****                         #if( UART_1_HD_ENABLED )
 589:.\Generated_Source\PSoC5/UART_1.c ****                             if((UART_1_CONTROL_REG & UART_1_CTRL_HD_SEND) == 0u)
 590:.\Generated_Source\PSoC5/UART_1.c ****                             {   /* In Half duplex mode return RX mask only if
 591:.\Generated_Source\PSoC5/UART_1.c ****                                 *  RX configuration set, otherwise
 592:.\Generated_Source\PSoC5/UART_1.c ****                                 *  mask will be returned in LoadRxConfig() API.
 593:.\Generated_Source\PSoC5/UART_1.c ****                                 */
 594:.\Generated_Source\PSoC5/UART_1.c ****                                 UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 595:.\Generated_Source\PSoC5/UART_1.c ****                             }
 596:.\Generated_Source\PSoC5/UART_1.c ****                         #else
 597:.\Generated_Source\PSoC5/UART_1.c ****                             UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 598:.\Generated_Source\PSoC5/UART_1.c ****                         #endif /* end UART_1_HD_ENABLED */
 599:.\Generated_Source\PSoC5/UART_1.c ****                     #endif /* UART_1_RX_INTERRUPT_ENABLED and Hardware flow control*/
 600:.\Generated_Source\PSoC5/UART_1.c ****                 }
 601:.\Generated_Source\PSoC5/UART_1.c **** 
 602:.\Generated_Source\PSoC5/UART_1.c ****             }
 603:.\Generated_Source\PSoC5/UART_1.c ****             else
 604:.\Generated_Source\PSoC5/UART_1.c ****             {   rxStatus = UART_1_RXSTATUS_REG;
 605:.\Generated_Source\PSoC5/UART_1.c ****                 if((rxStatus & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u)
 606:.\Generated_Source\PSoC5/UART_1.c ****                 {   /* Read received data from FIFO*/
 607:.\Generated_Source\PSoC5/UART_1.c ****                     rxData = UART_1_RXDATA_REG;
 608:.\Generated_Source\PSoC5/UART_1.c ****                     /*Check status on error*/
 609:.\Generated_Source\PSoC5/UART_1.c ****                     if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
 610:.\Generated_Source\PSoC5/UART_1.c ****                                    UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
 611:.\Generated_Source\PSoC5/UART_1.c ****                     {
 612:.\Generated_Source\PSoC5/UART_1.c ****                         rxData = 0u;
 613:.\Generated_Source\PSoC5/UART_1.c ****                     }
 614:.\Generated_Source\PSoC5/UART_1.c ****                 }
 615:.\Generated_Source\PSoC5/UART_1.c ****             }
 616:.\Generated_Source\PSoC5/UART_1.c **** 
 617:.\Generated_Source\PSoC5/UART_1.c ****             /* Enable Rx interrupt. */
 618:.\Generated_Source\PSoC5/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 619:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_EnableRxInt();
 620:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* UART_1_RX_INTERRUPT_ENABLED */
 621:.\Generated_Source\PSoC5/UART_1.c **** 
 622:.\Generated_Source\PSoC5/UART_1.c ****         #else /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 623:.\Generated_Source\PSoC5/UART_1.c **** 
 624:.\Generated_Source\PSoC5/UART_1.c ****             rxStatus =UART_1_RXSTATUS_REG;
 625:.\Generated_Source\PSoC5/UART_1.c ****             if((rxStatus & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u)
 626:.\Generated_Source\PSoC5/UART_1.c ****             {   /* Read received data from FIFO*/
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 17


 627:.\Generated_Source\PSoC5/UART_1.c ****                 rxData = UART_1_RXDATA_REG;
 628:.\Generated_Source\PSoC5/UART_1.c ****                 /*Check status on error*/
 629:.\Generated_Source\PSoC5/UART_1.c ****                 if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
 630:.\Generated_Source\PSoC5/UART_1.c ****                                UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
 631:.\Generated_Source\PSoC5/UART_1.c ****                 {
 632:.\Generated_Source\PSoC5/UART_1.c ****                     rxData = 0u;
 633:.\Generated_Source\PSoC5/UART_1.c ****                 }
 634:.\Generated_Source\PSoC5/UART_1.c ****             }
 635:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 636:.\Generated_Source\PSoC5/UART_1.c **** 
 637:.\Generated_Source\PSoC5/UART_1.c ****         return(rxData);
 638:.\Generated_Source\PSoC5/UART_1.c ****     }
 639:.\Generated_Source\PSoC5/UART_1.c **** 
 640:.\Generated_Source\PSoC5/UART_1.c **** 
 641:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 642:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_GetByte
 643:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 644:.\Generated_Source\PSoC5/UART_1.c ****     *
 645:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 646:.\Generated_Source\PSoC5/UART_1.c ****     *  Grab the next available byte of data from the recieve FIFO
 647:.\Generated_Source\PSoC5/UART_1.c ****     *
 648:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 649:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 650:.\Generated_Source\PSoC5/UART_1.c ****     *
 651:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 652:.\Generated_Source\PSoC5/UART_1.c ****     *  MSB contains Status Register and LSB contains UART RX data
 653:.\Generated_Source\PSoC5/UART_1.c ****     *
 654:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
 655:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
 656:.\Generated_Source\PSoC5/UART_1.c ****     *
 657:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 658:.\Generated_Source\PSoC5/UART_1.c ****     uint16 UART_1_GetByte(void) 
 659:.\Generated_Source\PSoC5/UART_1.c ****     {
 660:.\Generated_Source\PSoC5/UART_1.c ****         return ( ((uint16)UART_1_ReadRxStatus() << 8u) | UART_1_ReadRxData() );
 661:.\Generated_Source\PSoC5/UART_1.c ****     }
 662:.\Generated_Source\PSoC5/UART_1.c **** 
 663:.\Generated_Source\PSoC5/UART_1.c **** 
 664:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 665:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_GetRxBufferSize
 666:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 667:.\Generated_Source\PSoC5/UART_1.c ****     *
 668:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 669:.\Generated_Source\PSoC5/UART_1.c ****     *  Determine the amount of bytes left in the RX buffer and return the count in
 670:.\Generated_Source\PSoC5/UART_1.c ****     *  bytes
 671:.\Generated_Source\PSoC5/UART_1.c ****     *
 672:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 673:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 674:.\Generated_Source\PSoC5/UART_1.c ****     *
 675:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 676:.\Generated_Source\PSoC5/UART_1.c ****     *  uint8: Integer count of the number of bytes left
 677:.\Generated_Source\PSoC5/UART_1.c ****     *  in the RX buffer
 678:.\Generated_Source\PSoC5/UART_1.c ****     *
 679:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
 680:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferWrite - used to calculate left bytes.
 681:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferRead - used to calculate left bytes.
 682:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferLoopDetect - checked to decide left bytes amount.
 683:.\Generated_Source\PSoC5/UART_1.c ****     *
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 18


 684:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
 685:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
 686:.\Generated_Source\PSoC5/UART_1.c ****     *
 687:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
 688:.\Generated_Source\PSoC5/UART_1.c ****     *  Allows the user to find out how full the RX Buffer is.
 689:.\Generated_Source\PSoC5/UART_1.c ****     *
 690:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 691:.\Generated_Source\PSoC5/UART_1.c ****     uint8 UART_1_GetRxBufferSize(void)
 692:.\Generated_Source\PSoC5/UART_1.c ****                                                             
 693:.\Generated_Source\PSoC5/UART_1.c ****     {
 694:.\Generated_Source\PSoC5/UART_1.c ****         uint8 size;
 695:.\Generated_Source\PSoC5/UART_1.c **** 
 696:.\Generated_Source\PSoC5/UART_1.c ****         #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
 697:.\Generated_Source\PSoC5/UART_1.c **** 
 698:.\Generated_Source\PSoC5/UART_1.c ****             /* Disable Rx interrupt. */
 699:.\Generated_Source\PSoC5/UART_1.c ****             /* Protect variables that could change on interrupt. */
 700:.\Generated_Source\PSoC5/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 701:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_DisableRxInt();
 702:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* UART_1_RX_INTERRUPT_ENABLED */
 703:.\Generated_Source\PSoC5/UART_1.c **** 
 704:.\Generated_Source\PSoC5/UART_1.c ****             if(UART_1_rxBufferRead == UART_1_rxBufferWrite)
 705:.\Generated_Source\PSoC5/UART_1.c ****             {
 706:.\Generated_Source\PSoC5/UART_1.c ****                 if(UART_1_rxBufferLoopDetect > 0u)
 707:.\Generated_Source\PSoC5/UART_1.c ****                 {
 708:.\Generated_Source\PSoC5/UART_1.c ****                     size = UART_1_RXBUFFERSIZE;
 709:.\Generated_Source\PSoC5/UART_1.c ****                 }
 710:.\Generated_Source\PSoC5/UART_1.c ****                 else
 711:.\Generated_Source\PSoC5/UART_1.c ****                 {
 712:.\Generated_Source\PSoC5/UART_1.c ****                     size = 0u;
 713:.\Generated_Source\PSoC5/UART_1.c ****                 }
 714:.\Generated_Source\PSoC5/UART_1.c ****             }
 715:.\Generated_Source\PSoC5/UART_1.c ****             else if(UART_1_rxBufferRead < UART_1_rxBufferWrite)
 716:.\Generated_Source\PSoC5/UART_1.c ****             {
 717:.\Generated_Source\PSoC5/UART_1.c ****                 size = (UART_1_rxBufferWrite - UART_1_rxBufferRead);
 718:.\Generated_Source\PSoC5/UART_1.c ****             }
 719:.\Generated_Source\PSoC5/UART_1.c ****             else
 720:.\Generated_Source\PSoC5/UART_1.c ****             {
 721:.\Generated_Source\PSoC5/UART_1.c ****                 size = (UART_1_RXBUFFERSIZE - UART_1_rxBufferRead) + UART_1_rxBufferWrite;
 722:.\Generated_Source\PSoC5/UART_1.c ****             }
 723:.\Generated_Source\PSoC5/UART_1.c **** 
 724:.\Generated_Source\PSoC5/UART_1.c ****             /* Enable Rx interrupt. */
 725:.\Generated_Source\PSoC5/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 726:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_EnableRxInt();
 727:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 728:.\Generated_Source\PSoC5/UART_1.c **** 
 729:.\Generated_Source\PSoC5/UART_1.c ****         #else /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 730:.\Generated_Source\PSoC5/UART_1.c **** 
 731:.\Generated_Source\PSoC5/UART_1.c ****             /* We can only know if there is data in the fifo. */
 732:.\Generated_Source\PSoC5/UART_1.c ****             size = ((UART_1_RXSTATUS_REG & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u) ? 1u : 0u;
 733:.\Generated_Source\PSoC5/UART_1.c **** 
 734:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 735:.\Generated_Source\PSoC5/UART_1.c **** 
 736:.\Generated_Source\PSoC5/UART_1.c ****         return(size);
 737:.\Generated_Source\PSoC5/UART_1.c ****     }
 738:.\Generated_Source\PSoC5/UART_1.c **** 
 739:.\Generated_Source\PSoC5/UART_1.c **** 
 740:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 19


 741:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_ClearRxBuffer
 742:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 743:.\Generated_Source\PSoC5/UART_1.c ****     *
 744:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 745:.\Generated_Source\PSoC5/UART_1.c ****     *  Clears the RX RAM buffer by setting the read and write pointers both to zero.
 746:.\Generated_Source\PSoC5/UART_1.c ****     *  Clears hardware RX FIFO.
 747:.\Generated_Source\PSoC5/UART_1.c ****     *
 748:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 749:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 750:.\Generated_Source\PSoC5/UART_1.c ****     *
 751:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 752:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 753:.\Generated_Source\PSoC5/UART_1.c ****     *
 754:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
 755:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferWrite - cleared to zero.
 756:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferRead - cleared to zero.
 757:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferLoopDetect - cleared to zero.
 758:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferOverflow - cleared to zero.
 759:.\Generated_Source\PSoC5/UART_1.c ****     *
 760:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
 761:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
 762:.\Generated_Source\PSoC5/UART_1.c ****     *
 763:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
 764:.\Generated_Source\PSoC5/UART_1.c ****     *  Setting the pointers to zero makes the system believe there is no data to
 765:.\Generated_Source\PSoC5/UART_1.c ****     *  read and writing will resume at address 0 overwriting any data that may
 766:.\Generated_Source\PSoC5/UART_1.c ****     *  have remained in the RAM.
 767:.\Generated_Source\PSoC5/UART_1.c ****     *
 768:.\Generated_Source\PSoC5/UART_1.c ****     * Side Effects:
 769:.\Generated_Source\PSoC5/UART_1.c ****     *  Any received data not read from the RAM or FIFO buffer will be lost.
 770:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 771:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_ClearRxBuffer(void) 
 772:.\Generated_Source\PSoC5/UART_1.c ****     {
 773:.\Generated_Source\PSoC5/UART_1.c ****         uint8 enableInterrupts;
 774:.\Generated_Source\PSoC5/UART_1.c **** 
 775:.\Generated_Source\PSoC5/UART_1.c ****         /* clear the HW FIFO */
 776:.\Generated_Source\PSoC5/UART_1.c ****         /* Enter critical section */
 777:.\Generated_Source\PSoC5/UART_1.c ****         enableInterrupts = CyEnterCriticalSection();
 778:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXDATA_AUX_CTL_REG |=  UART_1_RX_FIFO_CLR;
 779:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXDATA_AUX_CTL_REG &= (uint8)~UART_1_RX_FIFO_CLR;
 780:.\Generated_Source\PSoC5/UART_1.c ****         /* Exit critical section */
 781:.\Generated_Source\PSoC5/UART_1.c ****         CyExitCriticalSection(enableInterrupts);
 782:.\Generated_Source\PSoC5/UART_1.c **** 
 783:.\Generated_Source\PSoC5/UART_1.c ****         #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
 784:.\Generated_Source\PSoC5/UART_1.c ****             /* Disable Rx interrupt. */
 785:.\Generated_Source\PSoC5/UART_1.c ****             /* Protect variables that could change on interrupt. */
 786:.\Generated_Source\PSoC5/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 787:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_DisableRxInt();
 788:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 789:.\Generated_Source\PSoC5/UART_1.c **** 
 790:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_rxBufferRead = 0u;
 791:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_rxBufferWrite = 0u;
 792:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_rxBufferLoopDetect = 0u;
 793:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_rxBufferOverflow = 0u;
 794:.\Generated_Source\PSoC5/UART_1.c **** 
 795:.\Generated_Source\PSoC5/UART_1.c ****             /* Enable Rx interrupt. */
 796:.\Generated_Source\PSoC5/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 797:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_EnableRxInt();
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 20


 798:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 799:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 800:.\Generated_Source\PSoC5/UART_1.c **** 
 801:.\Generated_Source\PSoC5/UART_1.c ****     }
 802:.\Generated_Source\PSoC5/UART_1.c **** 
 803:.\Generated_Source\PSoC5/UART_1.c **** 
 804:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 805:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_SetRxAddressMode
 806:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 807:.\Generated_Source\PSoC5/UART_1.c ****     *
 808:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 809:.\Generated_Source\PSoC5/UART_1.c ****     *  Set the receive addressing mode
 810:.\Generated_Source\PSoC5/UART_1.c ****     *
 811:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 812:.\Generated_Source\PSoC5/UART_1.c ****     *  addressMode: Enumerated value indicating the mode of RX addressing
 813:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1__B_UART__AM_SW_BYTE_BYTE -  Software Byte-by-Byte address
 814:.\Generated_Source\PSoC5/UART_1.c ****     *                                               detection
 815:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1__B_UART__AM_SW_DETECT_TO_BUFFER - Software Detect to Buffer
 816:.\Generated_Source\PSoC5/UART_1.c ****     *                                               address detection
 817:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1__B_UART__AM_HW_BYTE_BY_BYTE - Hardware Byte-by-Byte address
 818:.\Generated_Source\PSoC5/UART_1.c ****     *                                               detection
 819:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1__B_UART__AM_HW_DETECT_TO_BUFFER - Hardware Detect to Buffer
 820:.\Generated_Source\PSoC5/UART_1.c ****     *                                               address detection
 821:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1__B_UART__AM_NONE - No address detection
 822:.\Generated_Source\PSoC5/UART_1.c ****     *
 823:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 824:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 825:.\Generated_Source\PSoC5/UART_1.c ****     *
 826:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
 827:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxAddressMode - the parameter stored in this variable for
 828:.\Generated_Source\PSoC5/UART_1.c ****     *   the farther usage in RX ISR.
 829:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxAddressDetected - set to initial state (0).
 830:.\Generated_Source\PSoC5/UART_1.c ****     *
 831:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 832:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_SetRxAddressMode(uint8 addressMode)
 833:.\Generated_Source\PSoC5/UART_1.c ****                                                         
 834:.\Generated_Source\PSoC5/UART_1.c ****     {
 835:.\Generated_Source\PSoC5/UART_1.c ****         #if(UART_1_RXHW_ADDRESS_ENABLED)
 836:.\Generated_Source\PSoC5/UART_1.c ****             #if(UART_1_CONTROL_REG_REMOVED)
 837:.\Generated_Source\PSoC5/UART_1.c ****                 if(addressMode != 0u) { }     /* release compiler warning */
 838:.\Generated_Source\PSoC5/UART_1.c ****             #else /* UART_1_CONTROL_REG_REMOVED */
 839:.\Generated_Source\PSoC5/UART_1.c ****                 uint8 tmpCtrl;
 840:.\Generated_Source\PSoC5/UART_1.c ****                 tmpCtrl = UART_1_CONTROL_REG & (uint8)~UART_1_CTRL_RXADDR_MODE_MASK;
 841:.\Generated_Source\PSoC5/UART_1.c ****                 tmpCtrl |= (uint8)(addressMode << UART_1_CTRL_RXADDR_MODE0_SHIFT);
 842:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_CONTROL_REG = tmpCtrl;
 843:.\Generated_Source\PSoC5/UART_1.c ****                 #if(UART_1_RX_INTERRUPT_ENABLED && \
 844:.\Generated_Source\PSoC5/UART_1.c ****                    (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH) )
 845:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_rxAddressMode = addressMode;
 846:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_rxAddressDetected = 0u;
 847:.\Generated_Source\PSoC5/UART_1.c ****                 #endif /* End UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH*/
 848:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* End UART_1_CONTROL_REG_REMOVED */
 849:.\Generated_Source\PSoC5/UART_1.c ****         #else /* UART_1_RXHW_ADDRESS_ENABLED */
 850:.\Generated_Source\PSoC5/UART_1.c ****             if(addressMode != 0u) { }     /* release compiler warning */
 851:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
 852:.\Generated_Source\PSoC5/UART_1.c ****     }
 853:.\Generated_Source\PSoC5/UART_1.c **** 
 854:.\Generated_Source\PSoC5/UART_1.c **** 
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 21


 855:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 856:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_SetRxAddress1
 857:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 858:.\Generated_Source\PSoC5/UART_1.c ****     *
 859:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 860:.\Generated_Source\PSoC5/UART_1.c ****     *  Set the first hardware address compare value
 861:.\Generated_Source\PSoC5/UART_1.c ****     *
 862:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 863:.\Generated_Source\PSoC5/UART_1.c ****     *  address
 864:.\Generated_Source\PSoC5/UART_1.c ****     *
 865:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 866:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 867:.\Generated_Source\PSoC5/UART_1.c ****     *
 868:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 869:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_SetRxAddress1(uint8 address) 
 870:.\Generated_Source\PSoC5/UART_1.c **** 
 871:.\Generated_Source\PSoC5/UART_1.c ****     {
 872:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXADDRESS1_REG = address;
 873:.\Generated_Source\PSoC5/UART_1.c ****     }
 874:.\Generated_Source\PSoC5/UART_1.c **** 
 875:.\Generated_Source\PSoC5/UART_1.c **** 
 876:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 877:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_SetRxAddress2
 878:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 879:.\Generated_Source\PSoC5/UART_1.c ****     *
 880:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 881:.\Generated_Source\PSoC5/UART_1.c ****     *  Set the second hardware address compare value
 882:.\Generated_Source\PSoC5/UART_1.c ****     *
 883:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 884:.\Generated_Source\PSoC5/UART_1.c ****     *  address
 885:.\Generated_Source\PSoC5/UART_1.c ****     *
 886:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 887:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 888:.\Generated_Source\PSoC5/UART_1.c ****     *
 889:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 890:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_SetRxAddress2(uint8 address) 
 891:.\Generated_Source\PSoC5/UART_1.c ****     {
 892:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXADDRESS2_REG = address;
 893:.\Generated_Source\PSoC5/UART_1.c ****     }
 894:.\Generated_Source\PSoC5/UART_1.c **** 
 895:.\Generated_Source\PSoC5/UART_1.c **** #endif  /* UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 896:.\Generated_Source\PSoC5/UART_1.c **** 
 897:.\Generated_Source\PSoC5/UART_1.c **** 
 898:.\Generated_Source\PSoC5/UART_1.c **** #if( (UART_1_TX_ENABLED) || (UART_1_HD_ENABLED) )
 899:.\Generated_Source\PSoC5/UART_1.c **** 
 900:.\Generated_Source\PSoC5/UART_1.c ****     #if(UART_1_TX_INTERRUPT_ENABLED)
 901:.\Generated_Source\PSoC5/UART_1.c **** 
 902:.\Generated_Source\PSoC5/UART_1.c ****         /*******************************************************************************
 903:.\Generated_Source\PSoC5/UART_1.c ****         * Function Name: UART_1_EnableTxInt
 904:.\Generated_Source\PSoC5/UART_1.c ****         ********************************************************************************
 905:.\Generated_Source\PSoC5/UART_1.c ****         *
 906:.\Generated_Source\PSoC5/UART_1.c ****         * Summary:
 907:.\Generated_Source\PSoC5/UART_1.c ****         *  Enable TX interrupt generation
 908:.\Generated_Source\PSoC5/UART_1.c ****         *
 909:.\Generated_Source\PSoC5/UART_1.c ****         * Parameters:
 910:.\Generated_Source\PSoC5/UART_1.c ****         *  None.
 911:.\Generated_Source\PSoC5/UART_1.c ****         *
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 22


 912:.\Generated_Source\PSoC5/UART_1.c ****         * Return:
 913:.\Generated_Source\PSoC5/UART_1.c ****         *  None.
 914:.\Generated_Source\PSoC5/UART_1.c ****         *
 915:.\Generated_Source\PSoC5/UART_1.c ****         * Theory:
 916:.\Generated_Source\PSoC5/UART_1.c ****         *  Enable the interrupt output -or- the interrupt component itself
 917:.\Generated_Source\PSoC5/UART_1.c ****         *
 918:.\Generated_Source\PSoC5/UART_1.c ****         *******************************************************************************/
 919:.\Generated_Source\PSoC5/UART_1.c ****         void UART_1_EnableTxInt(void) 
 920:.\Generated_Source\PSoC5/UART_1.c ****         {
 921:.\Generated_Source\PSoC5/UART_1.c ****             CyIntEnable(UART_1_TX_VECT_NUM);
 922:.\Generated_Source\PSoC5/UART_1.c ****         }
 923:.\Generated_Source\PSoC5/UART_1.c **** 
 924:.\Generated_Source\PSoC5/UART_1.c **** 
 925:.\Generated_Source\PSoC5/UART_1.c ****         /*******************************************************************************
 926:.\Generated_Source\PSoC5/UART_1.c ****         * Function Name: UART_1_DisableTxInt
 927:.\Generated_Source\PSoC5/UART_1.c ****         ********************************************************************************
 928:.\Generated_Source\PSoC5/UART_1.c ****         *
 929:.\Generated_Source\PSoC5/UART_1.c ****         * Summary:
 930:.\Generated_Source\PSoC5/UART_1.c ****         *  Disable TX interrupt generation
 931:.\Generated_Source\PSoC5/UART_1.c ****         *
 932:.\Generated_Source\PSoC5/UART_1.c ****         * Parameters:
 933:.\Generated_Source\PSoC5/UART_1.c ****         *  None.
 934:.\Generated_Source\PSoC5/UART_1.c ****         *
 935:.\Generated_Source\PSoC5/UART_1.c ****         * Return:
 936:.\Generated_Source\PSoC5/UART_1.c ****         *  None.
 937:.\Generated_Source\PSoC5/UART_1.c ****         *
 938:.\Generated_Source\PSoC5/UART_1.c ****         * Theory:
 939:.\Generated_Source\PSoC5/UART_1.c ****         *  Disable the interrupt output -or- the interrupt component itself
 940:.\Generated_Source\PSoC5/UART_1.c ****         *
 941:.\Generated_Source\PSoC5/UART_1.c ****         *******************************************************************************/
 942:.\Generated_Source\PSoC5/UART_1.c ****         void UART_1_DisableTxInt(void) 
 943:.\Generated_Source\PSoC5/UART_1.c ****         {
 944:.\Generated_Source\PSoC5/UART_1.c ****             CyIntDisable(UART_1_TX_VECT_NUM);
 945:.\Generated_Source\PSoC5/UART_1.c ****         }
 946:.\Generated_Source\PSoC5/UART_1.c **** 
 947:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* UART_1_TX_INTERRUPT_ENABLED */
 948:.\Generated_Source\PSoC5/UART_1.c **** 
 949:.\Generated_Source\PSoC5/UART_1.c **** 
 950:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 951:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_SetTxInterruptMode
 952:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 953:.\Generated_Source\PSoC5/UART_1.c ****     *
 954:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 955:.\Generated_Source\PSoC5/UART_1.c ****     *  Configure which status bits trigger an interrupt event
 956:.\Generated_Source\PSoC5/UART_1.c ****     *
 957:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 958:.\Generated_Source\PSoC5/UART_1.c ****     *  intSrc: An or'd combination of the desired status bit masks (defined in
 959:.\Generated_Source\PSoC5/UART_1.c ****     *          the header file)
 960:.\Generated_Source\PSoC5/UART_1.c ****     *
 961:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 962:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 963:.\Generated_Source\PSoC5/UART_1.c ****     *
 964:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
 965:.\Generated_Source\PSoC5/UART_1.c ****     *  Enables the output of specific status bits to the interrupt controller
 966:.\Generated_Source\PSoC5/UART_1.c ****     *
 967:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 968:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_SetTxInterruptMode(uint8 intSrc) 
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 23


 969:.\Generated_Source\PSoC5/UART_1.c ****     {
 283              		.loc 1 969 0
 284              		.cfi_startproc
 285              		@ args = 0, pretend = 0, frame = 8
 286              		@ frame_needed = 1, uses_anonymous_args = 0
 287              		@ link register save eliminated.
 288 0000 80B4     		push	{r7}
 289              	.LCFI15:
 290              		.cfi_def_cfa_offset 4
 291 0002 83B0     		sub	sp, sp, #12
 292              	.LCFI16:
 293              		.cfi_def_cfa_offset 16
 294 0004 00AF     		add	r7, sp, #0
 295              		.cfi_offset 7, -4
 296              	.LCFI17:
 297              		.cfi_def_cfa_register 7
 298 0006 0346     		mov	r3, r0
 299 0008 FB71     		strb	r3, [r7, #7]
 970:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_TXSTATUS_MASK_REG = intSrc;
 300              		.loc 1 970 0
 301 000a 46F28753 		movw	r3, #:lower16:1073767815
 302 000e C4F20003 		movt	r3, #:upper16:1073767815
 303 0012 FA79     		ldrb	r2, [r7, #7]
 304 0014 1A70     		strb	r2, [r3, #0]
 971:.\Generated_Source\PSoC5/UART_1.c ****     }
 305              		.loc 1 971 0
 306 0016 07F10C07 		add	r7, r7, #12
 307 001a BD46     		mov	sp, r7
 308 001c 80BC     		pop	{r7}
 309 001e 7047     		bx	lr
 310              		.cfi_endproc
 311              	.LFE6:
 312              		.size	UART_1_SetTxInterruptMode, .-UART_1_SetTxInterruptMode
 313              		.section	.text.UART_1_WriteTxData,"ax",%progbits
 314              		.align	2
 315              		.global	UART_1_WriteTxData
 316              		.thumb
 317              		.thumb_func
 318              		.type	UART_1_WriteTxData, %function
 319              	UART_1_WriteTxData:
 320              	.LFB7:
 972:.\Generated_Source\PSoC5/UART_1.c **** 
 973:.\Generated_Source\PSoC5/UART_1.c **** 
 974:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 975:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_WriteTxData
 976:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 977:.\Generated_Source\PSoC5/UART_1.c ****     *
 978:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 979:.\Generated_Source\PSoC5/UART_1.c ****     *  Write a byte of data to the Transmit FIFO or TX buffer to be sent when the
 980:.\Generated_Source\PSoC5/UART_1.c ****     *  bus is available. WriteTxData sends a byte without checking for buffer room
 981:.\Generated_Source\PSoC5/UART_1.c ****     *  or status. It is up to the user to separately check status.
 982:.\Generated_Source\PSoC5/UART_1.c ****     *
 983:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 984:.\Generated_Source\PSoC5/UART_1.c ****     *  TXDataByte: byte of data to place in the transmit FIFO
 985:.\Generated_Source\PSoC5/UART_1.c ****     *
 986:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 987:.\Generated_Source\PSoC5/UART_1.c ****     * void
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 24


 988:.\Generated_Source\PSoC5/UART_1.c ****     *
 989:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
 990:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBuffer - RAM buffer pointer for save data for transmission
 991:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBufferWrite - cyclic index for write to txBuffer,
 992:.\Generated_Source\PSoC5/UART_1.c ****     *    incremented after each byte saved to buffer.
 993:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBufferRead - cyclic index for read from txBuffer,
 994:.\Generated_Source\PSoC5/UART_1.c ****     *    checked to identify the condition to write to FIFO directly or to TX buffer
 995:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
 996:.\Generated_Source\PSoC5/UART_1.c ****     *    initialized.
 997:.\Generated_Source\PSoC5/UART_1.c ****     *
 998:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
 999:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
1000:.\Generated_Source\PSoC5/UART_1.c ****     *
1001:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1002:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_WriteTxData(uint8 txDataByte) 
1003:.\Generated_Source\PSoC5/UART_1.c ****     {
 321              		.loc 1 1003 0
 322              		.cfi_startproc
 323              		@ args = 0, pretend = 0, frame = 8
 324              		@ frame_needed = 1, uses_anonymous_args = 0
 325              		@ link register save eliminated.
 326 0000 80B4     		push	{r7}
 327              	.LCFI18:
 328              		.cfi_def_cfa_offset 4
 329 0002 83B0     		sub	sp, sp, #12
 330              	.LCFI19:
 331              		.cfi_def_cfa_offset 16
 332 0004 00AF     		add	r7, sp, #0
 333              		.cfi_offset 7, -4
 334              	.LCFI20:
 335              		.cfi_def_cfa_register 7
 336 0006 0346     		mov	r3, r0
 337 0008 FB71     		strb	r3, [r7, #7]
1004:.\Generated_Source\PSoC5/UART_1.c ****         /* If not Initialized then skip this function*/
1005:.\Generated_Source\PSoC5/UART_1.c ****         if(UART_1_initVar != 0u)
 338              		.loc 1 1005 0
 339 000a 40F20003 		movw	r3, #:lower16:UART_1_initVar
 340 000e C0F20003 		movt	r3, #:upper16:UART_1_initVar
 341 0012 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 342 0014 002B     		cmp	r3, #0
 343 0016 05D0     		beq	.L18
1006:.\Generated_Source\PSoC5/UART_1.c ****         {
1007:.\Generated_Source\PSoC5/UART_1.c ****             #if(UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH)
1008:.\Generated_Source\PSoC5/UART_1.c **** 
1009:.\Generated_Source\PSoC5/UART_1.c ****                 /* Disable Tx interrupt. */
1010:.\Generated_Source\PSoC5/UART_1.c ****                 /* Protect variables that could change on interrupt. */
1011:.\Generated_Source\PSoC5/UART_1.c ****                 #if(UART_1_TX_INTERRUPT_ENABLED)
1012:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_DisableTxInt();
1013:.\Generated_Source\PSoC5/UART_1.c ****                 #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1014:.\Generated_Source\PSoC5/UART_1.c **** 
1015:.\Generated_Source\PSoC5/UART_1.c ****                 if( (UART_1_txBufferRead == UART_1_txBufferWrite) &&
1016:.\Generated_Source\PSoC5/UART_1.c ****                     ((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) == 0u) )
1017:.\Generated_Source\PSoC5/UART_1.c ****                 {
1018:.\Generated_Source\PSoC5/UART_1.c ****                     /* Add directly to the FIFO. */
1019:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_TXDATA_REG = txDataByte;
1020:.\Generated_Source\PSoC5/UART_1.c ****                 }
1021:.\Generated_Source\PSoC5/UART_1.c ****                 else
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 25


1022:.\Generated_Source\PSoC5/UART_1.c ****                 {
1023:.\Generated_Source\PSoC5/UART_1.c ****                     if(UART_1_txBufferWrite >= UART_1_TXBUFFERSIZE)
1024:.\Generated_Source\PSoC5/UART_1.c ****                     {
1025:.\Generated_Source\PSoC5/UART_1.c ****                         UART_1_txBufferWrite = 0u;
1026:.\Generated_Source\PSoC5/UART_1.c ****                     }
1027:.\Generated_Source\PSoC5/UART_1.c **** 
1028:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_txBuffer[UART_1_txBufferWrite] = txDataByte;
1029:.\Generated_Source\PSoC5/UART_1.c **** 
1030:.\Generated_Source\PSoC5/UART_1.c ****                     /* Add to the software buffer. */
1031:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_txBufferWrite++;
1032:.\Generated_Source\PSoC5/UART_1.c **** 
1033:.\Generated_Source\PSoC5/UART_1.c ****                 }
1034:.\Generated_Source\PSoC5/UART_1.c **** 
1035:.\Generated_Source\PSoC5/UART_1.c ****                 /* Enable Tx interrupt. */
1036:.\Generated_Source\PSoC5/UART_1.c ****                 #if(UART_1_TX_INTERRUPT_ENABLED)
1037:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_EnableTxInt();
1038:.\Generated_Source\PSoC5/UART_1.c ****                 #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1039:.\Generated_Source\PSoC5/UART_1.c **** 
1040:.\Generated_Source\PSoC5/UART_1.c ****             #else /* UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1041:.\Generated_Source\PSoC5/UART_1.c **** 
1042:.\Generated_Source\PSoC5/UART_1.c ****                 /* Add directly to the FIFO. */
1043:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_TXDATA_REG = txDataByte;
 344              		.loc 1 1043 0
 345 0018 46F24C43 		movw	r3, #:lower16:1073767500
 346 001c C4F20003 		movt	r3, #:upper16:1073767500
 347 0020 FA79     		ldrb	r2, [r7, #7]
 348 0022 1A70     		strb	r2, [r3, #0]
 349              	.L18:
1044:.\Generated_Source\PSoC5/UART_1.c **** 
1045:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* End UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1046:.\Generated_Source\PSoC5/UART_1.c ****         }
1047:.\Generated_Source\PSoC5/UART_1.c ****     }
 350              		.loc 1 1047 0
 351 0024 07F10C07 		add	r7, r7, #12
 352 0028 BD46     		mov	sp, r7
 353 002a 80BC     		pop	{r7}
 354 002c 7047     		bx	lr
 355              		.cfi_endproc
 356              	.LFE7:
 357              		.size	UART_1_WriteTxData, .-UART_1_WriteTxData
 358 002e 00BF     		.section	.text.UART_1_ReadTxStatus,"ax",%progbits
 359              		.align	2
 360              		.global	UART_1_ReadTxStatus
 361              		.thumb
 362              		.thumb_func
 363              		.type	UART_1_ReadTxStatus, %function
 364              	UART_1_ReadTxStatus:
 365              	.LFB8:
1048:.\Generated_Source\PSoC5/UART_1.c **** 
1049:.\Generated_Source\PSoC5/UART_1.c **** 
1050:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
1051:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_ReadTxStatus
1052:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
1053:.\Generated_Source\PSoC5/UART_1.c ****     *
1054:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
1055:.\Generated_Source\PSoC5/UART_1.c ****     *  Read the status register for the component
1056:.\Generated_Source\PSoC5/UART_1.c ****     *
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 26


1057:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
1058:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1059:.\Generated_Source\PSoC5/UART_1.c ****     *
1060:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
1061:.\Generated_Source\PSoC5/UART_1.c ****     *  Contents of the status register
1062:.\Generated_Source\PSoC5/UART_1.c ****     *
1063:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
1064:.\Generated_Source\PSoC5/UART_1.c ****     *  This function reads the status register which is clear on read. It is up to
1065:.\Generated_Source\PSoC5/UART_1.c ****     *  the user to handle all bits in this return value accordingly, even if the bit
1066:.\Generated_Source\PSoC5/UART_1.c ****     *  was not enabled as an interrupt source the event happened and must be handled
1067:.\Generated_Source\PSoC5/UART_1.c ****     *  accordingly.
1068:.\Generated_Source\PSoC5/UART_1.c ****     *
1069:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1070:.\Generated_Source\PSoC5/UART_1.c ****     uint8 UART_1_ReadTxStatus(void) 
1071:.\Generated_Source\PSoC5/UART_1.c ****     {
 366              		.loc 1 1071 0
 367              		.cfi_startproc
 368              		@ args = 0, pretend = 0, frame = 0
 369              		@ frame_needed = 1, uses_anonymous_args = 0
 370              		@ link register save eliminated.
 371 0000 80B4     		push	{r7}
 372              	.LCFI21:
 373              		.cfi_def_cfa_offset 4
 374 0002 00AF     		add	r7, sp, #0
 375              		.cfi_offset 7, -4
 376              	.LCFI22:
 377              		.cfi_def_cfa_register 7
1072:.\Generated_Source\PSoC5/UART_1.c ****         return(UART_1_TXSTATUS_REG);
 378              		.loc 1 1072 0
 379 0004 46F26753 		movw	r3, #:lower16:1073767783
 380 0008 C4F20003 		movt	r3, #:upper16:1073767783
 381 000c 1B78     		ldrb	r3, [r3, #0]
 382 000e DBB2     		uxtb	r3, r3
1073:.\Generated_Source\PSoC5/UART_1.c ****     }
 383              		.loc 1 1073 0
 384 0010 1846     		mov	r0, r3
 385 0012 BD46     		mov	sp, r7
 386 0014 80BC     		pop	{r7}
 387 0016 7047     		bx	lr
 388              		.cfi_endproc
 389              	.LFE8:
 390              		.size	UART_1_ReadTxStatus, .-UART_1_ReadTxStatus
 391              		.section	.text.UART_1_PutChar,"ax",%progbits
 392              		.align	2
 393              		.global	UART_1_PutChar
 394              		.thumb
 395              		.thumb_func
 396              		.type	UART_1_PutChar, %function
 397              	UART_1_PutChar:
 398              	.LFB9:
1074:.\Generated_Source\PSoC5/UART_1.c **** 
1075:.\Generated_Source\PSoC5/UART_1.c **** 
1076:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
1077:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_PutChar
1078:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
1079:.\Generated_Source\PSoC5/UART_1.c ****     *
1080:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 27


1081:.\Generated_Source\PSoC5/UART_1.c ****     *  Wait to send byte until TX register or buffer has room.
1082:.\Generated_Source\PSoC5/UART_1.c ****     *
1083:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
1084:.\Generated_Source\PSoC5/UART_1.c ****     *  txDataByte: The 8-bit data value to send across the UART.
1085:.\Generated_Source\PSoC5/UART_1.c ****     *
1086:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
1087:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1088:.\Generated_Source\PSoC5/UART_1.c ****     *
1089:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
1090:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBuffer - RAM buffer pointer for save data for transmission
1091:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBufferWrite - cyclic index for write to txBuffer,
1092:.\Generated_Source\PSoC5/UART_1.c ****     *     checked to identify free space in txBuffer and incremented after each byte
1093:.\Generated_Source\PSoC5/UART_1.c ****     *     saved to buffer.
1094:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBufferRead - cyclic index for read from txBuffer,
1095:.\Generated_Source\PSoC5/UART_1.c ****     *     checked to identify free space in txBuffer.
1096:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1097:.\Generated_Source\PSoC5/UART_1.c ****     *     initialized.
1098:.\Generated_Source\PSoC5/UART_1.c ****     *
1099:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
1100:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
1101:.\Generated_Source\PSoC5/UART_1.c ****     *
1102:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
1103:.\Generated_Source\PSoC5/UART_1.c ****     *  Allows the user to transmit any byte of data in a single transfer
1104:.\Generated_Source\PSoC5/UART_1.c ****     *
1105:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1106:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_PutChar(uint8 txDataByte) 
1107:.\Generated_Source\PSoC5/UART_1.c ****     {
 399              		.loc 1 1107 0
 400              		.cfi_startproc
 401              		@ args = 0, pretend = 0, frame = 8
 402              		@ frame_needed = 1, uses_anonymous_args = 0
 403              		@ link register save eliminated.
 404 0000 80B4     		push	{r7}
 405              	.LCFI23:
 406              		.cfi_def_cfa_offset 4
 407 0002 83B0     		sub	sp, sp, #12
 408              	.LCFI24:
 409              		.cfi_def_cfa_offset 16
 410 0004 00AF     		add	r7, sp, #0
 411              		.cfi_offset 7, -4
 412              	.LCFI25:
 413              		.cfi_def_cfa_register 7
 414 0006 0346     		mov	r3, r0
 415 0008 FB71     		strb	r3, [r7, #7]
 416              	.L22:
1108:.\Generated_Source\PSoC5/UART_1.c ****             #if(UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH)
1109:.\Generated_Source\PSoC5/UART_1.c ****                 /* The temporary output pointer is used since it takes two instructions
1110:.\Generated_Source\PSoC5/UART_1.c ****                 *  to increment with a wrap, and we can't risk doing that with the real
1111:.\Generated_Source\PSoC5/UART_1.c ****                 *  pointer and getting an interrupt in between instructions.
1112:.\Generated_Source\PSoC5/UART_1.c ****                 */
1113:.\Generated_Source\PSoC5/UART_1.c ****                 uint8 loc_txBufferWrite;
1114:.\Generated_Source\PSoC5/UART_1.c ****                 uint8 loc_txBufferRead;
1115:.\Generated_Source\PSoC5/UART_1.c **** 
1116:.\Generated_Source\PSoC5/UART_1.c ****                 do{
1117:.\Generated_Source\PSoC5/UART_1.c ****                     /* Block if software buffer is full, so we don't overwrite. */
1118:.\Generated_Source\PSoC5/UART_1.c ****                     #if ((UART_1_TXBUFFERSIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1119:.\Generated_Source\PSoC5/UART_1.c ****                         /* Disable TX interrupt to protect variables that could change on interrupt
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 28


1120:.\Generated_Source\PSoC5/UART_1.c ****                         CyIntDisable(UART_1_TX_VECT_NUM);
1121:.\Generated_Source\PSoC5/UART_1.c ****                     #endif /* End TXBUFFERSIZE > 255 */
1122:.\Generated_Source\PSoC5/UART_1.c ****                     loc_txBufferWrite = UART_1_txBufferWrite;
1123:.\Generated_Source\PSoC5/UART_1.c ****                     loc_txBufferRead = UART_1_txBufferRead;
1124:.\Generated_Source\PSoC5/UART_1.c ****                     #if ((UART_1_TXBUFFERSIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1125:.\Generated_Source\PSoC5/UART_1.c ****                         /* Enable interrupt to continue transmission */
1126:.\Generated_Source\PSoC5/UART_1.c ****                         CyIntEnable(UART_1_TX_VECT_NUM);
1127:.\Generated_Source\PSoC5/UART_1.c ****                     #endif /* End TXBUFFERSIZE > 255 */
1128:.\Generated_Source\PSoC5/UART_1.c ****                 }while( (loc_txBufferWrite < loc_txBufferRead) ? (loc_txBufferWrite == (loc_txBuffe
1129:.\Generated_Source\PSoC5/UART_1.c ****                                         ((loc_txBufferWrite - loc_txBufferRead) ==
1130:.\Generated_Source\PSoC5/UART_1.c ****                                         (uint8)(UART_1_TXBUFFERSIZE - 1u)) );
1131:.\Generated_Source\PSoC5/UART_1.c **** 
1132:.\Generated_Source\PSoC5/UART_1.c ****                 if( (loc_txBufferRead == loc_txBufferWrite) &&
1133:.\Generated_Source\PSoC5/UART_1.c ****                     ((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) == 0u) )
1134:.\Generated_Source\PSoC5/UART_1.c ****                 {
1135:.\Generated_Source\PSoC5/UART_1.c ****                     /* Add directly to the FIFO. */
1136:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_TXDATA_REG = txDataByte;
1137:.\Generated_Source\PSoC5/UART_1.c ****                 }
1138:.\Generated_Source\PSoC5/UART_1.c ****                 else
1139:.\Generated_Source\PSoC5/UART_1.c ****                 {
1140:.\Generated_Source\PSoC5/UART_1.c ****                     if(loc_txBufferWrite >= UART_1_TXBUFFERSIZE)
1141:.\Generated_Source\PSoC5/UART_1.c ****                     {
1142:.\Generated_Source\PSoC5/UART_1.c ****                         loc_txBufferWrite = 0u;
1143:.\Generated_Source\PSoC5/UART_1.c ****                     }
1144:.\Generated_Source\PSoC5/UART_1.c ****                     /* Add to the software buffer. */
1145:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_txBuffer[loc_txBufferWrite] = txDataByte;
1146:.\Generated_Source\PSoC5/UART_1.c ****                     loc_txBufferWrite++;
1147:.\Generated_Source\PSoC5/UART_1.c **** 
1148:.\Generated_Source\PSoC5/UART_1.c ****                     /* Finally, update the real output pointer */
1149:.\Generated_Source\PSoC5/UART_1.c ****                     #if ((UART_1_TXBUFFERSIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1150:.\Generated_Source\PSoC5/UART_1.c ****                         CyIntDisable(UART_1_TX_VECT_NUM);
1151:.\Generated_Source\PSoC5/UART_1.c ****                     #endif /* End TXBUFFERSIZE > 255 */
1152:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_txBufferWrite = loc_txBufferWrite;
1153:.\Generated_Source\PSoC5/UART_1.c ****                     #if ((UART_1_TXBUFFERSIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1154:.\Generated_Source\PSoC5/UART_1.c ****                         CyIntEnable(UART_1_TX_VECT_NUM);
1155:.\Generated_Source\PSoC5/UART_1.c ****                     #endif /* End TXBUFFERSIZE > 255 */
1156:.\Generated_Source\PSoC5/UART_1.c ****                 }
1157:.\Generated_Source\PSoC5/UART_1.c **** 
1158:.\Generated_Source\PSoC5/UART_1.c ****             #else /* UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1159:.\Generated_Source\PSoC5/UART_1.c **** 
1160:.\Generated_Source\PSoC5/UART_1.c ****                 while((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) != 0u)
 417              		.loc 1 1160 0
 418 000a 46F26753 		movw	r3, #:lower16:1073767783
 419 000e C4F20003 		movt	r3, #:upper16:1073767783
 420 0012 1B78     		ldrb	r3, [r3, #0]
 421 0014 DBB2     		uxtb	r3, r3
 422 0016 03F00403 		and	r3, r3, #4
 423 001a 002B     		cmp	r3, #0
 424 001c F5D1     		bne	.L22
1161:.\Generated_Source\PSoC5/UART_1.c ****                 {
1162:.\Generated_Source\PSoC5/UART_1.c ****                     ; /* Wait for room in the FIFO. */
1163:.\Generated_Source\PSoC5/UART_1.c ****                 }
1164:.\Generated_Source\PSoC5/UART_1.c **** 
1165:.\Generated_Source\PSoC5/UART_1.c ****                 /* Add directly to the FIFO. */
1166:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_TXDATA_REG = txDataByte;
 425              		.loc 1 1166 0
 426 001e 46F24C43 		movw	r3, #:lower16:1073767500
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 29


 427 0022 C4F20003 		movt	r3, #:upper16:1073767500
 428 0026 FA79     		ldrb	r2, [r7, #7]
 429 0028 1A70     		strb	r2, [r3, #0]
1167:.\Generated_Source\PSoC5/UART_1.c **** 
1168:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* End UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1169:.\Generated_Source\PSoC5/UART_1.c ****     }
 430              		.loc 1 1169 0
 431 002a 07F10C07 		add	r7, r7, #12
 432 002e BD46     		mov	sp, r7
 433 0030 80BC     		pop	{r7}
 434 0032 7047     		bx	lr
 435              		.cfi_endproc
 436              	.LFE9:
 437              		.size	UART_1_PutChar, .-UART_1_PutChar
 438              		.section	.text.UART_1_PutString,"ax",%progbits
 439              		.align	2
 440              		.global	UART_1_PutString
 441              		.thumb
 442              		.thumb_func
 443              		.type	UART_1_PutString, %function
 444              	UART_1_PutString:
 445              	.LFB10:
1170:.\Generated_Source\PSoC5/UART_1.c **** 
1171:.\Generated_Source\PSoC5/UART_1.c **** 
1172:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
1173:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_PutString
1174:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
1175:.\Generated_Source\PSoC5/UART_1.c ****     *
1176:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
1177:.\Generated_Source\PSoC5/UART_1.c ****     *  Write a Sequence of bytes on the Transmit line. Data comes from RAM or ROM.
1178:.\Generated_Source\PSoC5/UART_1.c ****     *
1179:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
1180:.\Generated_Source\PSoC5/UART_1.c ****     *  string: char pointer to character string of Data to Send.
1181:.\Generated_Source\PSoC5/UART_1.c ****     *
1182:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
1183:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1184:.\Generated_Source\PSoC5/UART_1.c ****     *
1185:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
1186:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1187:.\Generated_Source\PSoC5/UART_1.c ****     *     initialized.
1188:.\Generated_Source\PSoC5/UART_1.c ****     *
1189:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
1190:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
1191:.\Generated_Source\PSoC5/UART_1.c ****     *
1192:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
1193:.\Generated_Source\PSoC5/UART_1.c ****     *  This function will block if there is not enough memory to place the whole
1194:.\Generated_Source\PSoC5/UART_1.c ****     *  string, it will block until the entire string has been written to the
1195:.\Generated_Source\PSoC5/UART_1.c ****     *  transmit buffer.
1196:.\Generated_Source\PSoC5/UART_1.c ****     *
1197:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1198:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_PutString(const char8 string[]) 
1199:.\Generated_Source\PSoC5/UART_1.c ****     {
 446              		.loc 1 1199 0
 447              		.cfi_startproc
 448              		@ args = 0, pretend = 0, frame = 16
 449              		@ frame_needed = 1, uses_anonymous_args = 0
 450 0000 80B5     		push	{r7, lr}
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 30


 451              	.LCFI26:
 452              		.cfi_def_cfa_offset 8
 453 0002 84B0     		sub	sp, sp, #16
 454              	.LCFI27:
 455              		.cfi_def_cfa_offset 24
 456 0004 00AF     		add	r7, sp, #0
 457              		.cfi_offset 14, -4
 458              		.cfi_offset 7, -8
 459              	.LCFI28:
 460              		.cfi_def_cfa_register 7
 461 0006 7860     		str	r0, [r7, #4]
1200:.\Generated_Source\PSoC5/UART_1.c ****         uint16 buf_index = 0u;
 462              		.loc 1 1200 0
 463 0008 4FF00003 		mov	r3, #0
 464 000c FB81     		strh	r3, [r7, #14]	@ movhi
1201:.\Generated_Source\PSoC5/UART_1.c ****         /* If not Initialized then skip this function*/
1202:.\Generated_Source\PSoC5/UART_1.c ****         if(UART_1_initVar != 0u)
 465              		.loc 1 1202 0
 466 000e 40F20003 		movw	r3, #:lower16:UART_1_initVar
 467 0012 C0F20003 		movt	r3, #:upper16:UART_1_initVar
 468 0016 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 469 0018 002B     		cmp	r3, #0
 470 001a 11D0     		beq	.L28
1203:.\Generated_Source\PSoC5/UART_1.c ****         {
1204:.\Generated_Source\PSoC5/UART_1.c ****             /* This is a blocking function, it will not exit until all data is sent*/
1205:.\Generated_Source\PSoC5/UART_1.c ****             while(string[buf_index] != (char8)0)
 471              		.loc 1 1205 0
 472 001c 0AE0     		b	.L26
 473              	.L27:
1206:.\Generated_Source\PSoC5/UART_1.c ****             {
1207:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_PutChar((uint8)string[buf_index]);
 474              		.loc 1 1207 0
 475 001e FA89     		ldrh	r2, [r7, #14]
 476 0020 7B68     		ldr	r3, [r7, #4]
 477 0022 1344     		add	r3, r2, r3
 478 0024 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 479 0026 1846     		mov	r0, r3
 480 0028 FFF7FEFF 		bl	UART_1_PutChar
1208:.\Generated_Source\PSoC5/UART_1.c ****                 buf_index++;
 481              		.loc 1 1208 0
 482 002c FB89     		ldrh	r3, [r7, #14]	@ movhi
 483 002e 03F10103 		add	r3, r3, #1
 484 0032 FB81     		strh	r3, [r7, #14]	@ movhi
 485              	.L26:
 486              		.loc 1 1205 0
 487 0034 FA89     		ldrh	r2, [r7, #14]
 488 0036 7B68     		ldr	r3, [r7, #4]
 489 0038 1344     		add	r3, r2, r3
 490 003a 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 491 003c 002B     		cmp	r3, #0
 492 003e EED1     		bne	.L27
 493              	.L28:
1209:.\Generated_Source\PSoC5/UART_1.c ****             }
1210:.\Generated_Source\PSoC5/UART_1.c ****         }
1211:.\Generated_Source\PSoC5/UART_1.c ****     }
 494              		.loc 1 1211 0
 495 0040 07F11007 		add	r7, r7, #16
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 31


 496 0044 BD46     		mov	sp, r7
 497 0046 80BD     		pop	{r7, pc}
 498              		.cfi_endproc
 499              	.LFE10:
 500              		.size	UART_1_PutString, .-UART_1_PutString
 501              		.section	.text.UART_1_PutArray,"ax",%progbits
 502              		.align	2
 503              		.global	UART_1_PutArray
 504              		.thumb
 505              		.thumb_func
 506              		.type	UART_1_PutArray, %function
 507              	UART_1_PutArray:
 508              	.LFB11:
1212:.\Generated_Source\PSoC5/UART_1.c **** 
1213:.\Generated_Source\PSoC5/UART_1.c **** 
1214:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
1215:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_PutArray
1216:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
1217:.\Generated_Source\PSoC5/UART_1.c ****     *
1218:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
1219:.\Generated_Source\PSoC5/UART_1.c ****     *  Write a Sequence of bytes on the Transmit line. Data comes from RAM or ROM.
1220:.\Generated_Source\PSoC5/UART_1.c ****     *
1221:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
1222:.\Generated_Source\PSoC5/UART_1.c ****     *  string: Address of the memory array residing in RAM or ROM.
1223:.\Generated_Source\PSoC5/UART_1.c ****     *  byteCount: Number of Bytes to be transmitted.
1224:.\Generated_Source\PSoC5/UART_1.c ****     *
1225:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
1226:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1227:.\Generated_Source\PSoC5/UART_1.c ****     *
1228:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
1229:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1230:.\Generated_Source\PSoC5/UART_1.c ****     *     initialized.
1231:.\Generated_Source\PSoC5/UART_1.c ****     *
1232:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
1233:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
1234:.\Generated_Source\PSoC5/UART_1.c ****     *
1235:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1236:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_PutArray(const uint8 string[], uint8 byteCount)
1237:.\Generated_Source\PSoC5/UART_1.c ****                                                                     
1238:.\Generated_Source\PSoC5/UART_1.c ****     {
 509              		.loc 1 1238 0
 510              		.cfi_startproc
 511              		@ args = 0, pretend = 0, frame = 16
 512              		@ frame_needed = 1, uses_anonymous_args = 0
 513 0000 80B5     		push	{r7, lr}
 514              	.LCFI29:
 515              		.cfi_def_cfa_offset 8
 516 0002 84B0     		sub	sp, sp, #16
 517              	.LCFI30:
 518              		.cfi_def_cfa_offset 24
 519 0004 00AF     		add	r7, sp, #0
 520              		.cfi_offset 14, -4
 521              		.cfi_offset 7, -8
 522              	.LCFI31:
 523              		.cfi_def_cfa_register 7
 524 0006 7860     		str	r0, [r7, #4]
 525 0008 0B46     		mov	r3, r1
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 32


 526 000a FB70     		strb	r3, [r7, #3]
1239:.\Generated_Source\PSoC5/UART_1.c ****         uint8 buf_index = 0u;
 527              		.loc 1 1239 0
 528 000c 4FF00003 		mov	r3, #0
 529 0010 FB73     		strb	r3, [r7, #15]
1240:.\Generated_Source\PSoC5/UART_1.c ****         /* If not Initialized then skip this function*/
1241:.\Generated_Source\PSoC5/UART_1.c ****         if(UART_1_initVar != 0u)
 530              		.loc 1 1241 0
 531 0012 40F20003 		movw	r3, #:lower16:UART_1_initVar
 532 0016 C0F20003 		movt	r3, #:upper16:UART_1_initVar
 533 001a 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 534 001c 002B     		cmp	r3, #0
 535 001e 0ED0     		beq	.L32
 536              	.L31:
1242:.\Generated_Source\PSoC5/UART_1.c ****         {
1243:.\Generated_Source\PSoC5/UART_1.c ****             do
1244:.\Generated_Source\PSoC5/UART_1.c ****             {
1245:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_PutChar(string[buf_index]);
 537              		.loc 1 1245 0
 538 0020 FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 539 0022 7B68     		ldr	r3, [r7, #4]
 540 0024 1344     		add	r3, r2, r3
 541 0026 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 542 0028 1846     		mov	r0, r3
 543 002a FFF7FEFF 		bl	UART_1_PutChar
1246:.\Generated_Source\PSoC5/UART_1.c ****                 buf_index++;
 544              		.loc 1 1246 0
 545 002e FB7B     		ldrb	r3, [r7, #15]
 546 0030 03F10103 		add	r3, r3, #1
 547 0034 FB73     		strb	r3, [r7, #15]
1247:.\Generated_Source\PSoC5/UART_1.c ****             }while(buf_index < byteCount);
 548              		.loc 1 1247 0
 549 0036 FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 550 0038 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 551 003a 9A42     		cmp	r2, r3
 552 003c F0D3     		bcc	.L31
 553              	.L32:
1248:.\Generated_Source\PSoC5/UART_1.c ****         }
1249:.\Generated_Source\PSoC5/UART_1.c ****     }
 554              		.loc 1 1249 0
 555 003e 07F11007 		add	r7, r7, #16
 556 0042 BD46     		mov	sp, r7
 557 0044 80BD     		pop	{r7, pc}
 558              		.cfi_endproc
 559              	.LFE11:
 560              		.size	UART_1_PutArray, .-UART_1_PutArray
 561 0046 00BF     		.section	.text.UART_1_PutCRLF,"ax",%progbits
 562              		.align	2
 563              		.global	UART_1_PutCRLF
 564              		.thumb
 565              		.thumb_func
 566              		.type	UART_1_PutCRLF, %function
 567              	UART_1_PutCRLF:
 568              	.LFB12:
1250:.\Generated_Source\PSoC5/UART_1.c **** 
1251:.\Generated_Source\PSoC5/UART_1.c **** 
1252:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 33


1253:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_PutCRLF
1254:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
1255:.\Generated_Source\PSoC5/UART_1.c ****     *
1256:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
1257:.\Generated_Source\PSoC5/UART_1.c ****     *  Write a character and then carriage return and line feed.
1258:.\Generated_Source\PSoC5/UART_1.c ****     *
1259:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
1260:.\Generated_Source\PSoC5/UART_1.c ****     *  txDataByte: uint8 Character to send.
1261:.\Generated_Source\PSoC5/UART_1.c ****     *
1262:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
1263:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1264:.\Generated_Source\PSoC5/UART_1.c ****     *
1265:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
1266:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1267:.\Generated_Source\PSoC5/UART_1.c ****     *     initialized.
1268:.\Generated_Source\PSoC5/UART_1.c ****     *
1269:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
1270:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
1271:.\Generated_Source\PSoC5/UART_1.c ****     *
1272:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1273:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_PutCRLF(uint8 txDataByte) 
1274:.\Generated_Source\PSoC5/UART_1.c ****     {
 569              		.loc 1 1274 0
 570              		.cfi_startproc
 571              		@ args = 0, pretend = 0, frame = 8
 572              		@ frame_needed = 1, uses_anonymous_args = 0
 573 0000 80B5     		push	{r7, lr}
 574              	.LCFI32:
 575              		.cfi_def_cfa_offset 8
 576 0002 82B0     		sub	sp, sp, #8
 577              	.LCFI33:
 578              		.cfi_def_cfa_offset 16
 579 0004 00AF     		add	r7, sp, #0
 580              		.cfi_offset 14, -4
 581              		.cfi_offset 7, -8
 582              	.LCFI34:
 583              		.cfi_def_cfa_register 7
 584 0006 0346     		mov	r3, r0
 585 0008 FB71     		strb	r3, [r7, #7]
1275:.\Generated_Source\PSoC5/UART_1.c ****         /* If not Initialized then skip this function*/
1276:.\Generated_Source\PSoC5/UART_1.c ****         if(UART_1_initVar != 0u)
 586              		.loc 1 1276 0
 587 000a 40F20003 		movw	r3, #:lower16:UART_1_initVar
 588 000e C0F20003 		movt	r3, #:upper16:UART_1_initVar
 589 0012 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 590 0014 002B     		cmp	r3, #0
 591 0016 0BD0     		beq	.L35
1277:.\Generated_Source\PSoC5/UART_1.c ****         {
1278:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_PutChar(txDataByte);
 592              		.loc 1 1278 0
 593 0018 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 594 001a 1846     		mov	r0, r3
 595 001c FFF7FEFF 		bl	UART_1_PutChar
1279:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_PutChar(0x0Du);
 596              		.loc 1 1279 0
 597 0020 4FF00D00 		mov	r0, #13
 598 0024 FFF7FEFF 		bl	UART_1_PutChar
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 34


1280:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_PutChar(0x0Au);
 599              		.loc 1 1280 0
 600 0028 4FF00A00 		mov	r0, #10
 601 002c FFF7FEFF 		bl	UART_1_PutChar
 602              	.L35:
1281:.\Generated_Source\PSoC5/UART_1.c ****         }
1282:.\Generated_Source\PSoC5/UART_1.c ****     }
 603              		.loc 1 1282 0
 604 0030 07F10807 		add	r7, r7, #8
 605 0034 BD46     		mov	sp, r7
 606 0036 80BD     		pop	{r7, pc}
 607              		.cfi_endproc
 608              	.LFE12:
 609              		.size	UART_1_PutCRLF, .-UART_1_PutCRLF
 610              		.section	.text.UART_1_GetTxBufferSize,"ax",%progbits
 611              		.align	2
 612              		.global	UART_1_GetTxBufferSize
 613              		.thumb
 614              		.thumb_func
 615              		.type	UART_1_GetTxBufferSize, %function
 616              	UART_1_GetTxBufferSize:
 617              	.LFB13:
1283:.\Generated_Source\PSoC5/UART_1.c **** 
1284:.\Generated_Source\PSoC5/UART_1.c **** 
1285:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
1286:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_GetTxBufferSize
1287:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
1288:.\Generated_Source\PSoC5/UART_1.c ****     *
1289:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
1290:.\Generated_Source\PSoC5/UART_1.c ****     *  Determine the amount of space left in the TX buffer and return the count in
1291:.\Generated_Source\PSoC5/UART_1.c ****     *  bytes
1292:.\Generated_Source\PSoC5/UART_1.c ****     *
1293:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
1294:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1295:.\Generated_Source\PSoC5/UART_1.c ****     *
1296:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
1297:.\Generated_Source\PSoC5/UART_1.c ****     *  Integer count of the number of bytes left in the TX buffer
1298:.\Generated_Source\PSoC5/UART_1.c ****     *
1299:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
1300:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBufferWrite - used to calculate left space.
1301:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBufferRead - used to calculate left space.
1302:.\Generated_Source\PSoC5/UART_1.c ****     *
1303:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
1304:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
1305:.\Generated_Source\PSoC5/UART_1.c ****     *
1306:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
1307:.\Generated_Source\PSoC5/UART_1.c ****     *  Allows the user to find out how full the TX Buffer is.
1308:.\Generated_Source\PSoC5/UART_1.c ****     *
1309:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1310:.\Generated_Source\PSoC5/UART_1.c ****     uint8 UART_1_GetTxBufferSize(void)
1311:.\Generated_Source\PSoC5/UART_1.c ****                                                             
1312:.\Generated_Source\PSoC5/UART_1.c ****     {
 618              		.loc 1 1312 0
 619              		.cfi_startproc
 620              		@ args = 0, pretend = 0, frame = 8
 621              		@ frame_needed = 1, uses_anonymous_args = 0
 622              		@ link register save eliminated.
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 35


 623 0000 80B4     		push	{r7}
 624              	.LCFI35:
 625              		.cfi_def_cfa_offset 4
 626 0002 83B0     		sub	sp, sp, #12
 627              	.LCFI36:
 628              		.cfi_def_cfa_offset 16
 629 0004 00AF     		add	r7, sp, #0
 630              		.cfi_offset 7, -4
 631              	.LCFI37:
 632              		.cfi_def_cfa_register 7
1313:.\Generated_Source\PSoC5/UART_1.c ****         uint8 size;
1314:.\Generated_Source\PSoC5/UART_1.c **** 
1315:.\Generated_Source\PSoC5/UART_1.c ****         #if(UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH)
1316:.\Generated_Source\PSoC5/UART_1.c **** 
1317:.\Generated_Source\PSoC5/UART_1.c ****             /* Disable Tx interrupt. */
1318:.\Generated_Source\PSoC5/UART_1.c ****             /* Protect variables that could change on interrupt. */
1319:.\Generated_Source\PSoC5/UART_1.c ****             #if(UART_1_TX_INTERRUPT_ENABLED)
1320:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_DisableTxInt();
1321:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1322:.\Generated_Source\PSoC5/UART_1.c **** 
1323:.\Generated_Source\PSoC5/UART_1.c ****             if(UART_1_txBufferRead == UART_1_txBufferWrite)
1324:.\Generated_Source\PSoC5/UART_1.c ****             {
1325:.\Generated_Source\PSoC5/UART_1.c ****                 size = 0u;
1326:.\Generated_Source\PSoC5/UART_1.c ****             }
1327:.\Generated_Source\PSoC5/UART_1.c ****             else if(UART_1_txBufferRead < UART_1_txBufferWrite)
1328:.\Generated_Source\PSoC5/UART_1.c ****             {
1329:.\Generated_Source\PSoC5/UART_1.c ****                 size = (UART_1_txBufferWrite - UART_1_txBufferRead);
1330:.\Generated_Source\PSoC5/UART_1.c ****             }
1331:.\Generated_Source\PSoC5/UART_1.c ****             else
1332:.\Generated_Source\PSoC5/UART_1.c ****             {
1333:.\Generated_Source\PSoC5/UART_1.c ****                 size = (UART_1_TXBUFFERSIZE - UART_1_txBufferRead) + UART_1_txBufferWrite;
1334:.\Generated_Source\PSoC5/UART_1.c ****             }
1335:.\Generated_Source\PSoC5/UART_1.c **** 
1336:.\Generated_Source\PSoC5/UART_1.c ****             /* Enable Tx interrupt. */
1337:.\Generated_Source\PSoC5/UART_1.c ****             #if(UART_1_TX_INTERRUPT_ENABLED)
1338:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_EnableTxInt();
1339:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1340:.\Generated_Source\PSoC5/UART_1.c **** 
1341:.\Generated_Source\PSoC5/UART_1.c ****         #else /* UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1342:.\Generated_Source\PSoC5/UART_1.c **** 
1343:.\Generated_Source\PSoC5/UART_1.c ****             size = UART_1_TXSTATUS_REG;
 633              		.loc 1 1343 0
 634 0006 46F26753 		movw	r3, #:lower16:1073767783
 635 000a C4F20003 		movt	r3, #:upper16:1073767783
 636 000e 1B78     		ldrb	r3, [r3, #0]
 637 0010 FB71     		strb	r3, [r7, #7]
1344:.\Generated_Source\PSoC5/UART_1.c **** 
1345:.\Generated_Source\PSoC5/UART_1.c ****             /* Is the fifo is full. */
1346:.\Generated_Source\PSoC5/UART_1.c ****             if((size & UART_1_TX_STS_FIFO_FULL) != 0u)
 638              		.loc 1 1346 0
 639 0012 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 640 0014 03F00403 		and	r3, r3, #4
 641 0018 002B     		cmp	r3, #0
 642 001a 03D0     		beq	.L37
1347:.\Generated_Source\PSoC5/UART_1.c ****             {
1348:.\Generated_Source\PSoC5/UART_1.c ****                 size = UART_1_FIFO_LENGTH;
 643              		.loc 1 1348 0
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 36


 644 001c 4FF00403 		mov	r3, #4
 645 0020 FB71     		strb	r3, [r7, #7]
 646 0022 0BE0     		b	.L38
 647              	.L37:
1349:.\Generated_Source\PSoC5/UART_1.c ****             }
1350:.\Generated_Source\PSoC5/UART_1.c ****             else if((size & UART_1_TX_STS_FIFO_EMPTY) != 0u)
 648              		.loc 1 1350 0
 649 0024 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 650 0026 03F00203 		and	r3, r3, #2
 651 002a 002B     		cmp	r3, #0
 652 002c 03D0     		beq	.L39
1351:.\Generated_Source\PSoC5/UART_1.c ****             {
1352:.\Generated_Source\PSoC5/UART_1.c ****                 size = 0u;
 653              		.loc 1 1352 0
 654 002e 4FF00003 		mov	r3, #0
 655 0032 FB71     		strb	r3, [r7, #7]
 656 0034 02E0     		b	.L38
 657              	.L39:
1353:.\Generated_Source\PSoC5/UART_1.c ****             }
1354:.\Generated_Source\PSoC5/UART_1.c ****             else
1355:.\Generated_Source\PSoC5/UART_1.c ****             {
1356:.\Generated_Source\PSoC5/UART_1.c ****                 /* We only know there is data in the fifo. */
1357:.\Generated_Source\PSoC5/UART_1.c ****                 size = 1u;
 658              		.loc 1 1357 0
 659 0036 4FF00103 		mov	r3, #1
 660 003a FB71     		strb	r3, [r7, #7]
 661              	.L38:
1358:.\Generated_Source\PSoC5/UART_1.c ****             }
1359:.\Generated_Source\PSoC5/UART_1.c **** 
1360:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1361:.\Generated_Source\PSoC5/UART_1.c **** 
1362:.\Generated_Source\PSoC5/UART_1.c ****         return(size);
 662              		.loc 1 1362 0
 663 003c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
1363:.\Generated_Source\PSoC5/UART_1.c ****     }
 664              		.loc 1 1363 0
 665 003e 1846     		mov	r0, r3
 666 0040 07F10C07 		add	r7, r7, #12
 667 0044 BD46     		mov	sp, r7
 668 0046 80BC     		pop	{r7}
 669 0048 7047     		bx	lr
 670              		.cfi_endproc
 671              	.LFE13:
 672              		.size	UART_1_GetTxBufferSize, .-UART_1_GetTxBufferSize
 673 004a 00BF     		.section	.text.UART_1_ClearTxBuffer,"ax",%progbits
 674              		.align	2
 675              		.global	UART_1_ClearTxBuffer
 676              		.thumb
 677              		.thumb_func
 678              		.type	UART_1_ClearTxBuffer, %function
 679              	UART_1_ClearTxBuffer:
 680              	.LFB14:
1364:.\Generated_Source\PSoC5/UART_1.c **** 
1365:.\Generated_Source\PSoC5/UART_1.c **** 
1366:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
1367:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_ClearTxBuffer
1368:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 37


1369:.\Generated_Source\PSoC5/UART_1.c ****     *
1370:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
1371:.\Generated_Source\PSoC5/UART_1.c ****     *  Clears the TX RAM buffer by setting the read and write pointers both to zero.
1372:.\Generated_Source\PSoC5/UART_1.c ****     *  Clears the hardware TX FIFO.  Any data present in the FIFO will not be sent.
1373:.\Generated_Source\PSoC5/UART_1.c ****     *
1374:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
1375:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1376:.\Generated_Source\PSoC5/UART_1.c ****     *
1377:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
1378:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1379:.\Generated_Source\PSoC5/UART_1.c ****     *
1380:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
1381:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBufferWrite - cleared to zero.
1382:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBufferRead - cleared to zero.
1383:.\Generated_Source\PSoC5/UART_1.c ****     *
1384:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
1385:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
1386:.\Generated_Source\PSoC5/UART_1.c ****     *
1387:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
1388:.\Generated_Source\PSoC5/UART_1.c ****     *  Setting the pointers to zero makes the system believe there is no data to
1389:.\Generated_Source\PSoC5/UART_1.c ****     *  read and writing will resume at address 0 overwriting any data that may have
1390:.\Generated_Source\PSoC5/UART_1.c ****     *  remained in the RAM.
1391:.\Generated_Source\PSoC5/UART_1.c ****     *
1392:.\Generated_Source\PSoC5/UART_1.c ****     * Side Effects:
1393:.\Generated_Source\PSoC5/UART_1.c ****     *  Any received data not read from the RAM buffer will be lost when overwritten.
1394:.\Generated_Source\PSoC5/UART_1.c ****     *
1395:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1396:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_ClearTxBuffer(void) 
1397:.\Generated_Source\PSoC5/UART_1.c ****     {
 681              		.loc 1 1397 0
 682              		.cfi_startproc
 683              		@ args = 0, pretend = 0, frame = 8
 684              		@ frame_needed = 1, uses_anonymous_args = 0
 685 0000 80B5     		push	{r7, lr}
 686              	.LCFI38:
 687              		.cfi_def_cfa_offset 8
 688 0002 82B0     		sub	sp, sp, #8
 689              	.LCFI39:
 690              		.cfi_def_cfa_offset 16
 691 0004 00AF     		add	r7, sp, #0
 692              		.cfi_offset 14, -4
 693              		.cfi_offset 7, -8
 694              	.LCFI40:
 695              		.cfi_def_cfa_register 7
1398:.\Generated_Source\PSoC5/UART_1.c ****         uint8 enableInterrupts;
1399:.\Generated_Source\PSoC5/UART_1.c **** 
1400:.\Generated_Source\PSoC5/UART_1.c ****         /* Enter critical section */
1401:.\Generated_Source\PSoC5/UART_1.c ****         enableInterrupts = CyEnterCriticalSection();
 696              		.loc 1 1401 0
 697 0006 FFF7FEFF 		bl	CyEnterCriticalSection
 698 000a 0346     		mov	r3, r0
 699 000c FB71     		strb	r3, [r7, #7]
1402:.\Generated_Source\PSoC5/UART_1.c ****         /* clear the HW FIFO */
1403:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_TXDATA_AUX_CTL_REG |=  UART_1_TX_FIFO_CLR;
 700              		.loc 1 1403 0
 701 000e 46F29C43 		movw	r3, #:lower16:1073767580
 702 0012 C4F20003 		movt	r3, #:upper16:1073767580
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 38


 703 0016 46F29C42 		movw	r2, #:lower16:1073767580
 704 001a C4F20002 		movt	r2, #:upper16:1073767580
 705 001e 1278     		ldrb	r2, [r2, #0]
 706 0020 D2B2     		uxtb	r2, r2
 707 0022 42F00102 		orr	r2, r2, #1
 708 0026 D2B2     		uxtb	r2, r2
 709 0028 1A70     		strb	r2, [r3, #0]
1404:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_TXDATA_AUX_CTL_REG &= (uint8)~UART_1_TX_FIFO_CLR;
 710              		.loc 1 1404 0
 711 002a 46F29C43 		movw	r3, #:lower16:1073767580
 712 002e C4F20003 		movt	r3, #:upper16:1073767580
 713 0032 46F29C42 		movw	r2, #:lower16:1073767580
 714 0036 C4F20002 		movt	r2, #:upper16:1073767580
 715 003a 1278     		ldrb	r2, [r2, #0]
 716 003c D2B2     		uxtb	r2, r2
 717 003e 02F0FE02 		and	r2, r2, #254
 718 0042 1A70     		strb	r2, [r3, #0]
1405:.\Generated_Source\PSoC5/UART_1.c ****         /* Exit critical section */
1406:.\Generated_Source\PSoC5/UART_1.c ****         CyExitCriticalSection(enableInterrupts);
 719              		.loc 1 1406 0
 720 0044 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 721 0046 1846     		mov	r0, r3
 722 0048 FFF7FEFF 		bl	CyExitCriticalSection
1407:.\Generated_Source\PSoC5/UART_1.c **** 
1408:.\Generated_Source\PSoC5/UART_1.c ****         #if(UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH)
1409:.\Generated_Source\PSoC5/UART_1.c **** 
1410:.\Generated_Source\PSoC5/UART_1.c ****             /* Disable Tx interrupt. */
1411:.\Generated_Source\PSoC5/UART_1.c ****             /* Protect variables that could change on interrupt. */
1412:.\Generated_Source\PSoC5/UART_1.c ****             #if(UART_1_TX_INTERRUPT_ENABLED)
1413:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_DisableTxInt();
1414:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1415:.\Generated_Source\PSoC5/UART_1.c **** 
1416:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_txBufferRead = 0u;
1417:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_txBufferWrite = 0u;
1418:.\Generated_Source\PSoC5/UART_1.c **** 
1419:.\Generated_Source\PSoC5/UART_1.c ****             /* Enable Tx interrupt. */
1420:.\Generated_Source\PSoC5/UART_1.c ****             #if(UART_1_TX_INTERRUPT_ENABLED)
1421:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_EnableTxInt();
1422:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1423:.\Generated_Source\PSoC5/UART_1.c **** 
1424:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1425:.\Generated_Source\PSoC5/UART_1.c ****     }
 723              		.loc 1 1425 0
 724 004c 07F10807 		add	r7, r7, #8
 725 0050 BD46     		mov	sp, r7
 726 0052 80BD     		pop	{r7, pc}
 727              		.cfi_endproc
 728              	.LFE14:
 729              		.size	UART_1_ClearTxBuffer, .-UART_1_ClearTxBuffer
 730              		.section	.text.UART_1_SendBreak,"ax",%progbits
 731              		.align	2
 732              		.global	UART_1_SendBreak
 733              		.thumb
 734              		.thumb_func
 735              		.type	UART_1_SendBreak, %function
 736              	UART_1_SendBreak:
 737              	.LFB15:
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 39


1426:.\Generated_Source\PSoC5/UART_1.c **** 
1427:.\Generated_Source\PSoC5/UART_1.c **** 
1428:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
1429:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_SendBreak
1430:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
1431:.\Generated_Source\PSoC5/UART_1.c ****     *
1432:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
1433:.\Generated_Source\PSoC5/UART_1.c ****     *  Write a Break command to the UART
1434:.\Generated_Source\PSoC5/UART_1.c ****     *
1435:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
1436:.\Generated_Source\PSoC5/UART_1.c ****     *  uint8 retMode:  Wait mode,
1437:.\Generated_Source\PSoC5/UART_1.c ****     *   0 - Initialize registers for Break, sends the Break signal and return
1438:.\Generated_Source\PSoC5/UART_1.c ****     *       imediately.
1439:.\Generated_Source\PSoC5/UART_1.c ****     *   1 - Wait until Break sending is complete, reinitialize registers to normal
1440:.\Generated_Source\PSoC5/UART_1.c ****     *       transmission mode then return.
1441:.\Generated_Source\PSoC5/UART_1.c ****     *   2 - Reinitialize registers to normal transmission mode then return.
1442:.\Generated_Source\PSoC5/UART_1.c ****     *   3 - both steps: 0 and 1
1443:.\Generated_Source\PSoC5/UART_1.c ****     *       init registers for Break, send Break signal
1444:.\Generated_Source\PSoC5/UART_1.c ****     *       wait until Break sending is complete, reinit registers to normal
1445:.\Generated_Source\PSoC5/UART_1.c ****     *       transmission mode then return.
1446:.\Generated_Source\PSoC5/UART_1.c ****     *
1447:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
1448:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1449:.\Generated_Source\PSoC5/UART_1.c ****     *
1450:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
1451:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1452:.\Generated_Source\PSoC5/UART_1.c ****     *     initialized.
1453:.\Generated_Source\PSoC5/UART_1.c ****     *  tx_period - static variable, used for keeping TX period configuration.
1454:.\Generated_Source\PSoC5/UART_1.c ****     *
1455:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
1456:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
1457:.\Generated_Source\PSoC5/UART_1.c ****     *
1458:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
1459:.\Generated_Source\PSoC5/UART_1.c ****     *  SendBreak function initializes registers to send 13-bit break signal. It is
1460:.\Generated_Source\PSoC5/UART_1.c ****     *  important to return the registers configuration to normal for continue 8-bit
1461:.\Generated_Source\PSoC5/UART_1.c ****     *  operation.
1462:.\Generated_Source\PSoC5/UART_1.c ****     *  Trere are 3 variants for this API usage:
1463:.\Generated_Source\PSoC5/UART_1.c ****     *  1) SendBreak(3) - function will send the Break signal and take care on the
1464:.\Generated_Source\PSoC5/UART_1.c ****     *     configuration returning. Funcition will block CPU untill transmition
1465:.\Generated_Source\PSoC5/UART_1.c ****     *     complete.
1466:.\Generated_Source\PSoC5/UART_1.c ****     *  2) User may want to use bloking time if UART configured to the low speed
1467:.\Generated_Source\PSoC5/UART_1.c ****     *     operation
1468:.\Generated_Source\PSoC5/UART_1.c ****     *     Emample for this case:
1469:.\Generated_Source\PSoC5/UART_1.c ****     *     SendBreak(0);     - init Break signal transmition
1470:.\Generated_Source\PSoC5/UART_1.c ****     *         Add your code here to use CPU time
1471:.\Generated_Source\PSoC5/UART_1.c ****     *     SendBreak(1);     - complete Break operation
1472:.\Generated_Source\PSoC5/UART_1.c ****     *  3) Same to 2) but user may want to init and use the interrupt for complete
1473:.\Generated_Source\PSoC5/UART_1.c ****     *     break operation.
1474:.\Generated_Source\PSoC5/UART_1.c ****     *     Example for this case:
1475:.\Generated_Source\PSoC5/UART_1.c ****     *     Init TX interrupt whith "TX - On TX Complete" parameter
1476:.\Generated_Source\PSoC5/UART_1.c ****     *     SendBreak(0);     - init Break signal transmition
1477:.\Generated_Source\PSoC5/UART_1.c ****     *         Add your code here to use CPU time
1478:.\Generated_Source\PSoC5/UART_1.c ****     *     When interrupt appear with UART_TX_STS_COMPLETE status:
1479:.\Generated_Source\PSoC5/UART_1.c ****     *     SendBreak(2);     - complete Break operation
1480:.\Generated_Source\PSoC5/UART_1.c ****     *
1481:.\Generated_Source\PSoC5/UART_1.c ****     * Side Effects:
1482:.\Generated_Source\PSoC5/UART_1.c ****     *   Uses static variable to keep registers configuration.
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 40


1483:.\Generated_Source\PSoC5/UART_1.c ****     *
1484:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1485:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_SendBreak(uint8 retMode) 
1486:.\Generated_Source\PSoC5/UART_1.c ****     {
 738              		.loc 1 1486 0
 739              		.cfi_startproc
 740              		@ args = 0, pretend = 0, frame = 16
 741              		@ frame_needed = 1, uses_anonymous_args = 0
 742              		@ link register save eliminated.
 743 0000 80B4     		push	{r7}
 744              	.LCFI41:
 745              		.cfi_def_cfa_offset 4
 746 0002 85B0     		sub	sp, sp, #20
 747              	.LCFI42:
 748              		.cfi_def_cfa_offset 24
 749 0004 00AF     		add	r7, sp, #0
 750              		.cfi_offset 7, -4
 751              	.LCFI43:
 752              		.cfi_def_cfa_register 7
 753 0006 0346     		mov	r3, r0
 754 0008 FB71     		strb	r3, [r7, #7]
1487:.\Generated_Source\PSoC5/UART_1.c **** 
1488:.\Generated_Source\PSoC5/UART_1.c ****         /* If not Initialized then skip this function*/
1489:.\Generated_Source\PSoC5/UART_1.c ****         if(UART_1_initVar != 0u)
 755              		.loc 1 1489 0
 756 000a 40F20003 		movw	r3, #:lower16:UART_1_initVar
 757 000e C0F20003 		movt	r3, #:upper16:UART_1_initVar
 758 0012 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 759 0014 002B     		cmp	r3, #0
 760 0016 54D0     		beq	.L53
 761              	.LBB2:
1490:.\Generated_Source\PSoC5/UART_1.c ****         {
1491:.\Generated_Source\PSoC5/UART_1.c ****             /*Set the Counter to 13-bits and transmit a 00 byte*/
1492:.\Generated_Source\PSoC5/UART_1.c ****             /*When that is done then reset the counter value back*/
1493:.\Generated_Source\PSoC5/UART_1.c ****             uint8 tmpStat;
1494:.\Generated_Source\PSoC5/UART_1.c **** 
1495:.\Generated_Source\PSoC5/UART_1.c ****             #if(UART_1_HD_ENABLED) /* Half Duplex mode*/
1496:.\Generated_Source\PSoC5/UART_1.c **** 
1497:.\Generated_Source\PSoC5/UART_1.c ****                 if( (retMode == UART_1_SEND_BREAK) ||
1498:.\Generated_Source\PSoC5/UART_1.c ****                     (retMode == UART_1_SEND_WAIT_REINIT ) )
1499:.\Generated_Source\PSoC5/UART_1.c ****                 {
1500:.\Generated_Source\PSoC5/UART_1.c ****                     /* CTRL_HD_SEND_BREAK - sends break bits in HD mode*/
1501:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1502:.\Generated_Source\PSoC5/UART_1.c ****                                                           UART_1_CTRL_HD_SEND_BREAK);
1503:.\Generated_Source\PSoC5/UART_1.c ****                     /* Send zeros*/
1504:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_TXDATA_REG = 0u;
1505:.\Generated_Source\PSoC5/UART_1.c **** 
1506:.\Generated_Source\PSoC5/UART_1.c ****                     do /*wait until transmit starts*/
1507:.\Generated_Source\PSoC5/UART_1.c ****                     {
1508:.\Generated_Source\PSoC5/UART_1.c ****                         tmpStat = UART_1_TXSTATUS_REG;
1509:.\Generated_Source\PSoC5/UART_1.c ****                     }while((tmpStat & UART_1_TX_STS_FIFO_EMPTY) != 0u);
1510:.\Generated_Source\PSoC5/UART_1.c ****                 }
1511:.\Generated_Source\PSoC5/UART_1.c **** 
1512:.\Generated_Source\PSoC5/UART_1.c ****                 if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
1513:.\Generated_Source\PSoC5/UART_1.c ****                     (retMode == UART_1_SEND_WAIT_REINIT) )
1514:.\Generated_Source\PSoC5/UART_1.c ****                 {
1515:.\Generated_Source\PSoC5/UART_1.c ****                     do /*wait until transmit complete*/
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 41


1516:.\Generated_Source\PSoC5/UART_1.c ****                     {
1517:.\Generated_Source\PSoC5/UART_1.c ****                         tmpStat = UART_1_TXSTATUS_REG;
1518:.\Generated_Source\PSoC5/UART_1.c ****                     }while(((uint8)~tmpStat & UART_1_TX_STS_COMPLETE) != 0u);
1519:.\Generated_Source\PSoC5/UART_1.c ****                 }
1520:.\Generated_Source\PSoC5/UART_1.c **** 
1521:.\Generated_Source\PSoC5/UART_1.c ****                 if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
1522:.\Generated_Source\PSoC5/UART_1.c ****                     (retMode == UART_1_REINIT) ||
1523:.\Generated_Source\PSoC5/UART_1.c ****                     (retMode == UART_1_SEND_WAIT_REINIT) )
1524:.\Generated_Source\PSoC5/UART_1.c ****                 {
1525:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1526:.\Generated_Source\PSoC5/UART_1.c ****                                                   (uint8)~UART_1_CTRL_HD_SEND_BREAK);
1527:.\Generated_Source\PSoC5/UART_1.c ****                 }
1528:.\Generated_Source\PSoC5/UART_1.c **** 
1529:.\Generated_Source\PSoC5/UART_1.c ****             #else /* UART_1_HD_ENABLED Full Duplex mode */
1530:.\Generated_Source\PSoC5/UART_1.c **** 
1531:.\Generated_Source\PSoC5/UART_1.c ****                 static uint8 tx_period;
1532:.\Generated_Source\PSoC5/UART_1.c **** 
1533:.\Generated_Source\PSoC5/UART_1.c ****                 if( (retMode == UART_1_SEND_BREAK) ||
 762              		.loc 1 1533 0
 763 0018 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 764 001a 002B     		cmp	r3, #0
 765 001c 02D0     		beq	.L45
 766 001e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 767 0020 032B     		cmp	r3, #3
 768 0022 23D1     		bne	.L46
 769              	.L45:
1534:.\Generated_Source\PSoC5/UART_1.c ****                     (retMode == UART_1_SEND_WAIT_REINIT) )
1535:.\Generated_Source\PSoC5/UART_1.c ****                 {
1536:.\Generated_Source\PSoC5/UART_1.c ****                     /* CTRL_HD_SEND_BREAK - skip to send parity bit at Break signal in Full Duplex 
1537:.\Generated_Source\PSoC5/UART_1.c ****                     #if( (UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB) || \
1538:.\Generated_Source\PSoC5/UART_1.c ****                                         (UART_1_PARITY_TYPE_SW != 0u) )
1539:.\Generated_Source\PSoC5/UART_1.c ****                         UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1540:.\Generated_Source\PSoC5/UART_1.c ****                                                               UART_1_CTRL_HD_SEND_BREAK);
1541:.\Generated_Source\PSoC5/UART_1.c ****                     #endif /* End UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB  */
1542:.\Generated_Source\PSoC5/UART_1.c **** 
1543:.\Generated_Source\PSoC5/UART_1.c ****                     #if(UART_1_TXCLKGEN_DP)
1544:.\Generated_Source\PSoC5/UART_1.c ****                         tx_period = UART_1_TXBITCLKTX_COMPLETE_REG;
 770              		.loc 1 1544 0
 771 0024 46F23853 		movw	r3, #:lower16:1073767736
 772 0028 C4F20003 		movt	r3, #:upper16:1073767736
 773 002c 1B78     		ldrb	r3, [r3, #0]
 774 002e DAB2     		uxtb	r2, r3
 775 0030 40F20003 		movw	r3, #:lower16:tx_period.2139
 776 0034 C0F20003 		movt	r3, #:upper16:tx_period.2139
 777 0038 1A70     		strb	r2, [r3, #0]
1545:.\Generated_Source\PSoC5/UART_1.c ****                         UART_1_TXBITCLKTX_COMPLETE_REG = UART_1_TXBITCTR_BREAKBITS;
 778              		.loc 1 1545 0
 779 003a 46F23853 		movw	r3, #:lower16:1073767736
 780 003e C4F20003 		movt	r3, #:upper16:1073767736
 781 0042 4FF06702 		mov	r2, #103
 782 0046 1A70     		strb	r2, [r3, #0]
1546:.\Generated_Source\PSoC5/UART_1.c ****                     #else
1547:.\Generated_Source\PSoC5/UART_1.c ****                         tx_period = UART_1_TXBITCTR_PERIOD_REG;
1548:.\Generated_Source\PSoC5/UART_1.c ****                         UART_1_TXBITCTR_PERIOD_REG = UART_1_TXBITCTR_BREAKBITS8X;
1549:.\Generated_Source\PSoC5/UART_1.c ****                     #endif /* End UART_1_TXCLKGEN_DP */
1550:.\Generated_Source\PSoC5/UART_1.c **** 
1551:.\Generated_Source\PSoC5/UART_1.c ****                     /* Send zeros*/
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 42


1552:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_TXDATA_REG = 0u;
 783              		.loc 1 1552 0
 784 0048 46F24C43 		movw	r3, #:lower16:1073767500
 785 004c C4F20003 		movt	r3, #:upper16:1073767500
 786 0050 4FF00002 		mov	r2, #0
 787 0054 1A70     		strb	r2, [r3, #0]
 788              	.L47:
1553:.\Generated_Source\PSoC5/UART_1.c **** 
1554:.\Generated_Source\PSoC5/UART_1.c ****                     do /* wait until transmit starts */
1555:.\Generated_Source\PSoC5/UART_1.c ****                     {
1556:.\Generated_Source\PSoC5/UART_1.c ****                         tmpStat = UART_1_TXSTATUS_REG;
 789              		.loc 1 1556 0
 790 0056 46F26753 		movw	r3, #:lower16:1073767783
 791 005a C4F20003 		movt	r3, #:upper16:1073767783
 792 005e 1B78     		ldrb	r3, [r3, #0]
 793 0060 FB73     		strb	r3, [r7, #15]
1557:.\Generated_Source\PSoC5/UART_1.c ****                     }while((tmpStat & UART_1_TX_STS_FIFO_EMPTY) != 0u);
 794              		.loc 1 1557 0
 795 0062 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 796 0064 03F00203 		and	r3, r3, #2
 797 0068 002B     		cmp	r3, #0
 798 006a F4D1     		bne	.L47
 799              	.L46:
1558:.\Generated_Source\PSoC5/UART_1.c ****                 }
1559:.\Generated_Source\PSoC5/UART_1.c **** 
1560:.\Generated_Source\PSoC5/UART_1.c ****                 if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
 800              		.loc 1 1560 0
 801 006c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 802 006e 012B     		cmp	r3, #1
 803 0070 02D0     		beq	.L48
 804 0072 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 805 0074 032B     		cmp	r3, #3
 806 0076 11D1     		bne	.L49
 807              	.L48:
1561:.\Generated_Source\PSoC5/UART_1.c ****                     (retMode == UART_1_SEND_WAIT_REINIT) )
1562:.\Generated_Source\PSoC5/UART_1.c ****                 {
1563:.\Generated_Source\PSoC5/UART_1.c ****                     do /*wait until transmit complete*/
1564:.\Generated_Source\PSoC5/UART_1.c ****                     {
1565:.\Generated_Source\PSoC5/UART_1.c ****                         tmpStat = UART_1_TXSTATUS_REG;
 808              		.loc 1 1565 0
 809 0078 46F26753 		movw	r3, #:lower16:1073767783
 810 007c C4F20003 		movt	r3, #:upper16:1073767783
 811 0080 1B78     		ldrb	r3, [r3, #0]
 812 0082 FB73     		strb	r3, [r7, #15]
1566:.\Generated_Source\PSoC5/UART_1.c ****                     }while(((uint8)~tmpStat & UART_1_TX_STS_COMPLETE) != 0u);
 813              		.loc 1 1566 0
 814 0084 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 815 0086 03F00103 		and	r3, r3, #1
 816 008a 002B     		cmp	r3, #0
 817 008c 02D1     		bne	.L50
 818 008e 4FF00103 		mov	r3, #1
 819 0092 01E0     		b	.L51
 820              	.L50:
 821 0094 4FF00003 		mov	r3, #0
 822              	.L51:
 823 0098 002B     		cmp	r3, #0
 824 009a EDD1     		bne	.L48
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 43


 825              	.L49:
1567:.\Generated_Source\PSoC5/UART_1.c ****                 }
1568:.\Generated_Source\PSoC5/UART_1.c **** 
1569:.\Generated_Source\PSoC5/UART_1.c ****                 if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
 826              		.loc 1 1569 0
 827 009c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 828 009e 012B     		cmp	r3, #1
 829 00a0 05D0     		beq	.L52
 830 00a2 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 831 00a4 022B     		cmp	r3, #2
 832 00a6 02D0     		beq	.L52
 833 00a8 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 834 00aa 032B     		cmp	r3, #3
 835 00ac 09D1     		bne	.L53
 836              	.L52:
1570:.\Generated_Source\PSoC5/UART_1.c ****                     (retMode == UART_1_REINIT) ||
1571:.\Generated_Source\PSoC5/UART_1.c ****                     (retMode == UART_1_SEND_WAIT_REINIT) )
1572:.\Generated_Source\PSoC5/UART_1.c ****                 {
1573:.\Generated_Source\PSoC5/UART_1.c **** 
1574:.\Generated_Source\PSoC5/UART_1.c ****                     #if(UART_1_TXCLKGEN_DP)
1575:.\Generated_Source\PSoC5/UART_1.c ****                         UART_1_TXBITCLKTX_COMPLETE_REG = tx_period;
 837              		.loc 1 1575 0
 838 00ae 46F23853 		movw	r3, #:lower16:1073767736
 839 00b2 C4F20003 		movt	r3, #:upper16:1073767736
 840 00b6 40F20002 		movw	r2, #:lower16:tx_period.2139
 841 00ba C0F20002 		movt	r2, #:upper16:tx_period.2139
 842 00be 1278     		ldrb	r2, [r2, #0]	@ zero_extendqisi2
 843 00c0 1A70     		strb	r2, [r3, #0]
 844              	.L53:
 845              	.LBE2:
1576:.\Generated_Source\PSoC5/UART_1.c ****                     #else
1577:.\Generated_Source\PSoC5/UART_1.c ****                         UART_1_TXBITCTR_PERIOD_REG = tx_period;
1578:.\Generated_Source\PSoC5/UART_1.c ****                     #endif /* End UART_1_TXCLKGEN_DP */
1579:.\Generated_Source\PSoC5/UART_1.c **** 
1580:.\Generated_Source\PSoC5/UART_1.c ****                     #if( (UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB) || \
1581:.\Generated_Source\PSoC5/UART_1.c ****                          (UART_1_PARITY_TYPE_SW != 0u) )
1582:.\Generated_Source\PSoC5/UART_1.c ****                         UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1583:.\Generated_Source\PSoC5/UART_1.c ****                                                       (uint8)~UART_1_CTRL_HD_SEND_BREAK);
1584:.\Generated_Source\PSoC5/UART_1.c ****                     #endif /* End UART_1_PARITY_TYPE != NONE */
1585:.\Generated_Source\PSoC5/UART_1.c ****                 }
1586:.\Generated_Source\PSoC5/UART_1.c ****             #endif    /* End UART_1_HD_ENABLED */
1587:.\Generated_Source\PSoC5/UART_1.c ****         }
1588:.\Generated_Source\PSoC5/UART_1.c ****     }
 846              		.loc 1 1588 0
 847 00c2 07F11407 		add	r7, r7, #20
 848 00c6 BD46     		mov	sp, r7
 849 00c8 80BC     		pop	{r7}
 850 00ca 7047     		bx	lr
 851              		.cfi_endproc
 852              	.LFE15:
 853              		.size	UART_1_SendBreak, .-UART_1_SendBreak
 854              		.section	.text.UART_1_SetTxAddressMode,"ax",%progbits
 855              		.align	2
 856              		.global	UART_1_SetTxAddressMode
 857              		.thumb
 858              		.thumb_func
 859              		.type	UART_1_SetTxAddressMode, %function
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 44


 860              	UART_1_SetTxAddressMode:
 861              	.LFB16:
1589:.\Generated_Source\PSoC5/UART_1.c **** 
1590:.\Generated_Source\PSoC5/UART_1.c **** 
1591:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
1592:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_SetTxAddressMode
1593:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
1594:.\Generated_Source\PSoC5/UART_1.c ****     *
1595:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
1596:.\Generated_Source\PSoC5/UART_1.c ****     *  Set the transmit addressing mode
1597:.\Generated_Source\PSoC5/UART_1.c ****     *
1598:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
1599:.\Generated_Source\PSoC5/UART_1.c ****     *  addressMode: 0 -> Space
1600:.\Generated_Source\PSoC5/UART_1.c ****     *               1 -> Mark
1601:.\Generated_Source\PSoC5/UART_1.c ****     *
1602:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
1603:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1604:.\Generated_Source\PSoC5/UART_1.c ****     *
1605:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1606:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_SetTxAddressMode(uint8 addressMode) 
1607:.\Generated_Source\PSoC5/UART_1.c ****     {
 862              		.loc 1 1607 0
 863              		.cfi_startproc
 864              		@ args = 0, pretend = 0, frame = 8
 865              		@ frame_needed = 1, uses_anonymous_args = 0
 866              		@ link register save eliminated.
 867 0000 80B4     		push	{r7}
 868              	.LCFI44:
 869              		.cfi_def_cfa_offset 4
 870 0002 83B0     		sub	sp, sp, #12
 871              	.LCFI45:
 872              		.cfi_def_cfa_offset 16
 873 0004 00AF     		add	r7, sp, #0
 874              		.cfi_offset 7, -4
 875              	.LCFI46:
 876              		.cfi_def_cfa_register 7
 877 0006 0346     		mov	r3, r0
 878 0008 FB71     		strb	r3, [r7, #7]
1608:.\Generated_Source\PSoC5/UART_1.c ****         /* Mark/Space sending enable*/
1609:.\Generated_Source\PSoC5/UART_1.c ****         if(addressMode != 0u)
1610:.\Generated_Source\PSoC5/UART_1.c ****         {
1611:.\Generated_Source\PSoC5/UART_1.c ****             #if( UART_1_CONTROL_REG_REMOVED == 0u )
1612:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1613:.\Generated_Source\PSoC5/UART_1.c ****                                                       UART_1_CTRL_MARK);
1614:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* End UART_1_CONTROL_REG_REMOVED == 0u */
1615:.\Generated_Source\PSoC5/UART_1.c ****         }
1616:.\Generated_Source\PSoC5/UART_1.c ****         else
1617:.\Generated_Source\PSoC5/UART_1.c ****         {
1618:.\Generated_Source\PSoC5/UART_1.c ****             #if( UART_1_CONTROL_REG_REMOVED == 0u )
1619:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1620:.\Generated_Source\PSoC5/UART_1.c ****                                                     (uint8)~UART_1_CTRL_MARK);
1621:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* End UART_1_CONTROL_REG_REMOVED == 0u */
1622:.\Generated_Source\PSoC5/UART_1.c ****         }
1623:.\Generated_Source\PSoC5/UART_1.c ****     }
 879              		.loc 1 1623 0
 880 000a 07F10C07 		add	r7, r7, #12
 881 000e BD46     		mov	sp, r7
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 45


 882 0010 80BC     		pop	{r7}
 883 0012 7047     		bx	lr
 884              		.cfi_endproc
 885              	.LFE16:
 886              		.size	UART_1_SetTxAddressMode, .-UART_1_SetTxAddressMode
 887              		.bss
 888              	tx_period.2139:
 889 0001 00       		.space	1
 890              		.text
 891              	.Letext0:
 892              		.section	.debug_loc,"",%progbits
 893              	.Ldebug_loc0:
 894              	.LLST0:
 895 0000 00000000 		.4byte	.LFB0
 896 0004 02000000 		.4byte	.LCFI0
 897 0008 0100     		.2byte	0x1
 898 000a 5D       		.byte	0x5d
 899 000b 02000000 		.4byte	.LCFI0
 900 000f 04000000 		.4byte	.LCFI1
 901 0013 0200     		.2byte	0x2
 902 0015 7D       		.byte	0x7d
 903 0016 08       		.sleb128 8
 904 0017 04000000 		.4byte	.LCFI1
 905 001b 2A000000 		.4byte	.LFE0
 906 001f 0200     		.2byte	0x2
 907 0021 77       		.byte	0x77
 908 0022 08       		.sleb128 8
 909 0023 00000000 		.4byte	0x0
 910 0027 00000000 		.4byte	0x0
 911              	.LLST1:
 912 002b 00000000 		.4byte	.LFB1
 913 002f 02000000 		.4byte	.LCFI2
 914 0033 0100     		.2byte	0x1
 915 0035 5D       		.byte	0x5d
 916 0036 02000000 		.4byte	.LCFI2
 917 003a 04000000 		.4byte	.LCFI3
 918 003e 0200     		.2byte	0x2
 919 0040 7D       		.byte	0x7d
 920 0041 04       		.sleb128 4
 921 0042 04000000 		.4byte	.LCFI3
 922 0046 34000000 		.4byte	.LFE1
 923 004a 0200     		.2byte	0x2
 924 004c 77       		.byte	0x77
 925 004d 04       		.sleb128 4
 926 004e 00000000 		.4byte	0x0
 927 0052 00000000 		.4byte	0x0
 928              	.LLST2:
 929 0056 00000000 		.4byte	.LFB2
 930 005a 02000000 		.4byte	.LCFI4
 931 005e 0100     		.2byte	0x1
 932 0060 5D       		.byte	0x5d
 933 0061 02000000 		.4byte	.LCFI4
 934 0065 04000000 		.4byte	.LCFI5
 935 0069 0200     		.2byte	0x2
 936 006b 7D       		.byte	0x7d
 937 006c 08       		.sleb128 8
 938 006d 04000000 		.4byte	.LCFI5
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 46


 939 0071 06000000 		.4byte	.LCFI6
 940 0075 0200     		.2byte	0x2
 941 0077 7D       		.byte	0x7d
 942 0078 10       		.sleb128 16
 943 0079 06000000 		.4byte	.LCFI6
 944 007d 3E000000 		.4byte	.LFE2
 945 0081 0200     		.2byte	0x2
 946 0083 77       		.byte	0x77
 947 0084 10       		.sleb128 16
 948 0085 00000000 		.4byte	0x0
 949 0089 00000000 		.4byte	0x0
 950              	.LLST3:
 951 008d 00000000 		.4byte	.LFB3
 952 0091 02000000 		.4byte	.LCFI7
 953 0095 0100     		.2byte	0x1
 954 0097 5D       		.byte	0x5d
 955 0098 02000000 		.4byte	.LCFI7
 956 009c 04000000 		.4byte	.LCFI8
 957 00a0 0200     		.2byte	0x2
 958 00a2 7D       		.byte	0x7d
 959 00a3 08       		.sleb128 8
 960 00a4 04000000 		.4byte	.LCFI8
 961 00a8 06000000 		.4byte	.LCFI9
 962 00ac 0200     		.2byte	0x2
 963 00ae 7D       		.byte	0x7d
 964 00af 10       		.sleb128 16
 965 00b0 06000000 		.4byte	.LCFI9
 966 00b4 3C000000 		.4byte	.LFE3
 967 00b8 0200     		.2byte	0x2
 968 00ba 77       		.byte	0x77
 969 00bb 10       		.sleb128 16
 970 00bc 00000000 		.4byte	0x0
 971 00c0 00000000 		.4byte	0x0
 972              	.LLST4:
 973 00c4 00000000 		.4byte	.LFB4
 974 00c8 02000000 		.4byte	.LCFI10
 975 00cc 0100     		.2byte	0x1
 976 00ce 5D       		.byte	0x5d
 977 00cf 02000000 		.4byte	.LCFI10
 978 00d3 04000000 		.4byte	.LCFI11
 979 00d7 0200     		.2byte	0x2
 980 00d9 7D       		.byte	0x7d
 981 00da 04       		.sleb128 4
 982 00db 04000000 		.4byte	.LCFI11
 983 00df 10000000 		.4byte	.LFE4
 984 00e3 0200     		.2byte	0x2
 985 00e5 77       		.byte	0x77
 986 00e6 04       		.sleb128 4
 987 00e7 00000000 		.4byte	0x0
 988 00eb 00000000 		.4byte	0x0
 989              	.LLST5:
 990 00ef 00000000 		.4byte	.LFB5
 991 00f3 02000000 		.4byte	.LCFI12
 992 00f7 0100     		.2byte	0x1
 993 00f9 5D       		.byte	0x5d
 994 00fa 02000000 		.4byte	.LCFI12
 995 00fe 04000000 		.4byte	.LCFI13
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 47


 996 0102 0200     		.2byte	0x2
 997 0104 7D       		.byte	0x7d
 998 0105 04       		.sleb128 4
 999 0106 04000000 		.4byte	.LCFI13
 1000 010a 06000000 		.4byte	.LCFI14
 1001 010e 0200     		.2byte	0x2
 1002 0110 7D       		.byte	0x7d
 1003 0111 10       		.sleb128 16
 1004 0112 06000000 		.4byte	.LCFI14
 1005 0116 14000000 		.4byte	.LFE5
 1006 011a 0200     		.2byte	0x2
 1007 011c 77       		.byte	0x77
 1008 011d 10       		.sleb128 16
 1009 011e 00000000 		.4byte	0x0
 1010 0122 00000000 		.4byte	0x0
 1011              	.LLST6:
 1012 0126 00000000 		.4byte	.LFB6
 1013 012a 02000000 		.4byte	.LCFI15
 1014 012e 0100     		.2byte	0x1
 1015 0130 5D       		.byte	0x5d
 1016 0131 02000000 		.4byte	.LCFI15
 1017 0135 04000000 		.4byte	.LCFI16
 1018 0139 0200     		.2byte	0x2
 1019 013b 7D       		.byte	0x7d
 1020 013c 04       		.sleb128 4
 1021 013d 04000000 		.4byte	.LCFI16
 1022 0141 06000000 		.4byte	.LCFI17
 1023 0145 0200     		.2byte	0x2
 1024 0147 7D       		.byte	0x7d
 1025 0148 10       		.sleb128 16
 1026 0149 06000000 		.4byte	.LCFI17
 1027 014d 20000000 		.4byte	.LFE6
 1028 0151 0200     		.2byte	0x2
 1029 0153 77       		.byte	0x77
 1030 0154 10       		.sleb128 16
 1031 0155 00000000 		.4byte	0x0
 1032 0159 00000000 		.4byte	0x0
 1033              	.LLST7:
 1034 015d 00000000 		.4byte	.LFB7
 1035 0161 02000000 		.4byte	.LCFI18
 1036 0165 0100     		.2byte	0x1
 1037 0167 5D       		.byte	0x5d
 1038 0168 02000000 		.4byte	.LCFI18
 1039 016c 04000000 		.4byte	.LCFI19
 1040 0170 0200     		.2byte	0x2
 1041 0172 7D       		.byte	0x7d
 1042 0173 04       		.sleb128 4
 1043 0174 04000000 		.4byte	.LCFI19
 1044 0178 06000000 		.4byte	.LCFI20
 1045 017c 0200     		.2byte	0x2
 1046 017e 7D       		.byte	0x7d
 1047 017f 10       		.sleb128 16
 1048 0180 06000000 		.4byte	.LCFI20
 1049 0184 2E000000 		.4byte	.LFE7
 1050 0188 0200     		.2byte	0x2
 1051 018a 77       		.byte	0x77
 1052 018b 10       		.sleb128 16
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 48


 1053 018c 00000000 		.4byte	0x0
 1054 0190 00000000 		.4byte	0x0
 1055              	.LLST8:
 1056 0194 00000000 		.4byte	.LFB8
 1057 0198 02000000 		.4byte	.LCFI21
 1058 019c 0100     		.2byte	0x1
 1059 019e 5D       		.byte	0x5d
 1060 019f 02000000 		.4byte	.LCFI21
 1061 01a3 04000000 		.4byte	.LCFI22
 1062 01a7 0200     		.2byte	0x2
 1063 01a9 7D       		.byte	0x7d
 1064 01aa 04       		.sleb128 4
 1065 01ab 04000000 		.4byte	.LCFI22
 1066 01af 18000000 		.4byte	.LFE8
 1067 01b3 0200     		.2byte	0x2
 1068 01b5 77       		.byte	0x77
 1069 01b6 04       		.sleb128 4
 1070 01b7 00000000 		.4byte	0x0
 1071 01bb 00000000 		.4byte	0x0
 1072              	.LLST9:
 1073 01bf 00000000 		.4byte	.LFB9
 1074 01c3 02000000 		.4byte	.LCFI23
 1075 01c7 0100     		.2byte	0x1
 1076 01c9 5D       		.byte	0x5d
 1077 01ca 02000000 		.4byte	.LCFI23
 1078 01ce 04000000 		.4byte	.LCFI24
 1079 01d2 0200     		.2byte	0x2
 1080 01d4 7D       		.byte	0x7d
 1081 01d5 04       		.sleb128 4
 1082 01d6 04000000 		.4byte	.LCFI24
 1083 01da 06000000 		.4byte	.LCFI25
 1084 01de 0200     		.2byte	0x2
 1085 01e0 7D       		.byte	0x7d
 1086 01e1 10       		.sleb128 16
 1087 01e2 06000000 		.4byte	.LCFI25
 1088 01e6 34000000 		.4byte	.LFE9
 1089 01ea 0200     		.2byte	0x2
 1090 01ec 77       		.byte	0x77
 1091 01ed 10       		.sleb128 16
 1092 01ee 00000000 		.4byte	0x0
 1093 01f2 00000000 		.4byte	0x0
 1094              	.LLST10:
 1095 01f6 00000000 		.4byte	.LFB10
 1096 01fa 02000000 		.4byte	.LCFI26
 1097 01fe 0100     		.2byte	0x1
 1098 0200 5D       		.byte	0x5d
 1099 0201 02000000 		.4byte	.LCFI26
 1100 0205 04000000 		.4byte	.LCFI27
 1101 0209 0200     		.2byte	0x2
 1102 020b 7D       		.byte	0x7d
 1103 020c 08       		.sleb128 8
 1104 020d 04000000 		.4byte	.LCFI27
 1105 0211 06000000 		.4byte	.LCFI28
 1106 0215 0200     		.2byte	0x2
 1107 0217 7D       		.byte	0x7d
 1108 0218 18       		.sleb128 24
 1109 0219 06000000 		.4byte	.LCFI28
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 49


 1110 021d 48000000 		.4byte	.LFE10
 1111 0221 0200     		.2byte	0x2
 1112 0223 77       		.byte	0x77
 1113 0224 18       		.sleb128 24
 1114 0225 00000000 		.4byte	0x0
 1115 0229 00000000 		.4byte	0x0
 1116              	.LLST11:
 1117 022d 00000000 		.4byte	.LFB11
 1118 0231 02000000 		.4byte	.LCFI29
 1119 0235 0100     		.2byte	0x1
 1120 0237 5D       		.byte	0x5d
 1121 0238 02000000 		.4byte	.LCFI29
 1122 023c 04000000 		.4byte	.LCFI30
 1123 0240 0200     		.2byte	0x2
 1124 0242 7D       		.byte	0x7d
 1125 0243 08       		.sleb128 8
 1126 0244 04000000 		.4byte	.LCFI30
 1127 0248 06000000 		.4byte	.LCFI31
 1128 024c 0200     		.2byte	0x2
 1129 024e 7D       		.byte	0x7d
 1130 024f 18       		.sleb128 24
 1131 0250 06000000 		.4byte	.LCFI31
 1132 0254 46000000 		.4byte	.LFE11
 1133 0258 0200     		.2byte	0x2
 1134 025a 77       		.byte	0x77
 1135 025b 18       		.sleb128 24
 1136 025c 00000000 		.4byte	0x0
 1137 0260 00000000 		.4byte	0x0
 1138              	.LLST12:
 1139 0264 00000000 		.4byte	.LFB12
 1140 0268 02000000 		.4byte	.LCFI32
 1141 026c 0100     		.2byte	0x1
 1142 026e 5D       		.byte	0x5d
 1143 026f 02000000 		.4byte	.LCFI32
 1144 0273 04000000 		.4byte	.LCFI33
 1145 0277 0200     		.2byte	0x2
 1146 0279 7D       		.byte	0x7d
 1147 027a 08       		.sleb128 8
 1148 027b 04000000 		.4byte	.LCFI33
 1149 027f 06000000 		.4byte	.LCFI34
 1150 0283 0200     		.2byte	0x2
 1151 0285 7D       		.byte	0x7d
 1152 0286 10       		.sleb128 16
 1153 0287 06000000 		.4byte	.LCFI34
 1154 028b 38000000 		.4byte	.LFE12
 1155 028f 0200     		.2byte	0x2
 1156 0291 77       		.byte	0x77
 1157 0292 10       		.sleb128 16
 1158 0293 00000000 		.4byte	0x0
 1159 0297 00000000 		.4byte	0x0
 1160              	.LLST13:
 1161 029b 00000000 		.4byte	.LFB13
 1162 029f 02000000 		.4byte	.LCFI35
 1163 02a3 0100     		.2byte	0x1
 1164 02a5 5D       		.byte	0x5d
 1165 02a6 02000000 		.4byte	.LCFI35
 1166 02aa 04000000 		.4byte	.LCFI36
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 50


 1167 02ae 0200     		.2byte	0x2
 1168 02b0 7D       		.byte	0x7d
 1169 02b1 04       		.sleb128 4
 1170 02b2 04000000 		.4byte	.LCFI36
 1171 02b6 06000000 		.4byte	.LCFI37
 1172 02ba 0200     		.2byte	0x2
 1173 02bc 7D       		.byte	0x7d
 1174 02bd 10       		.sleb128 16
 1175 02be 06000000 		.4byte	.LCFI37
 1176 02c2 4A000000 		.4byte	.LFE13
 1177 02c6 0200     		.2byte	0x2
 1178 02c8 77       		.byte	0x77
 1179 02c9 10       		.sleb128 16
 1180 02ca 00000000 		.4byte	0x0
 1181 02ce 00000000 		.4byte	0x0
 1182              	.LLST14:
 1183 02d2 00000000 		.4byte	.LFB14
 1184 02d6 02000000 		.4byte	.LCFI38
 1185 02da 0100     		.2byte	0x1
 1186 02dc 5D       		.byte	0x5d
 1187 02dd 02000000 		.4byte	.LCFI38
 1188 02e1 04000000 		.4byte	.LCFI39
 1189 02e5 0200     		.2byte	0x2
 1190 02e7 7D       		.byte	0x7d
 1191 02e8 08       		.sleb128 8
 1192 02e9 04000000 		.4byte	.LCFI39
 1193 02ed 06000000 		.4byte	.LCFI40
 1194 02f1 0200     		.2byte	0x2
 1195 02f3 7D       		.byte	0x7d
 1196 02f4 10       		.sleb128 16
 1197 02f5 06000000 		.4byte	.LCFI40
 1198 02f9 54000000 		.4byte	.LFE14
 1199 02fd 0200     		.2byte	0x2
 1200 02ff 77       		.byte	0x77
 1201 0300 10       		.sleb128 16
 1202 0301 00000000 		.4byte	0x0
 1203 0305 00000000 		.4byte	0x0
 1204              	.LLST15:
 1205 0309 00000000 		.4byte	.LFB15
 1206 030d 02000000 		.4byte	.LCFI41
 1207 0311 0100     		.2byte	0x1
 1208 0313 5D       		.byte	0x5d
 1209 0314 02000000 		.4byte	.LCFI41
 1210 0318 04000000 		.4byte	.LCFI42
 1211 031c 0200     		.2byte	0x2
 1212 031e 7D       		.byte	0x7d
 1213 031f 04       		.sleb128 4
 1214 0320 04000000 		.4byte	.LCFI42
 1215 0324 06000000 		.4byte	.LCFI43
 1216 0328 0200     		.2byte	0x2
 1217 032a 7D       		.byte	0x7d
 1218 032b 18       		.sleb128 24
 1219 032c 06000000 		.4byte	.LCFI43
 1220 0330 CC000000 		.4byte	.LFE15
 1221 0334 0200     		.2byte	0x2
 1222 0336 77       		.byte	0x77
 1223 0337 18       		.sleb128 24
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 51


 1224 0338 00000000 		.4byte	0x0
 1225 033c 00000000 		.4byte	0x0
 1226              	.LLST16:
 1227 0340 00000000 		.4byte	.LFB16
 1228 0344 02000000 		.4byte	.LCFI44
 1229 0348 0100     		.2byte	0x1
 1230 034a 5D       		.byte	0x5d
 1231 034b 02000000 		.4byte	.LCFI44
 1232 034f 04000000 		.4byte	.LCFI45
 1233 0353 0200     		.2byte	0x2
 1234 0355 7D       		.byte	0x7d
 1235 0356 04       		.sleb128 4
 1236 0357 04000000 		.4byte	.LCFI45
 1237 035b 06000000 		.4byte	.LCFI46
 1238 035f 0200     		.2byte	0x2
 1239 0361 7D       		.byte	0x7d
 1240 0362 10       		.sleb128 16
 1241 0363 06000000 		.4byte	.LCFI46
 1242 0367 14000000 		.4byte	.LFE16
 1243 036b 0200     		.2byte	0x2
 1244 036d 77       		.byte	0x77
 1245 036e 10       		.sleb128 16
 1246 036f 00000000 		.4byte	0x0
 1247 0373 00000000 		.4byte	0x0
 1248              		.file 2 ".\\Generated_Source\\PSoC5\\/cytypes.h"
 1249              		.section	.debug_info
 1250 0000 A5030000 		.4byte	0x3a5
 1251 0004 0200     		.2byte	0x2
 1252 0006 00000000 		.4byte	.Ldebug_abbrev0
 1253 000a 04       		.byte	0x4
 1254 000b 01       		.uleb128 0x1
 1255 000c A0000000 		.4byte	.LASF43
 1256 0010 01       		.byte	0x1
 1257 0011 2B020000 		.4byte	.LASF44
 1258 0015 53010000 		.4byte	.LASF45
 1259 0019 00000000 		.4byte	0x0
 1260 001d 00000000 		.4byte	0x0
 1261 0021 00000000 		.4byte	.Ldebug_ranges0+0x0
 1262 0025 00000000 		.4byte	.Ldebug_line0
 1263 0029 02       		.uleb128 0x2
 1264 002a 01       		.byte	0x1
 1265 002b 06       		.byte	0x6
 1266 002c AE020000 		.4byte	.LASF0
 1267 0030 02       		.uleb128 0x2
 1268 0031 01       		.byte	0x1
 1269 0032 08       		.byte	0x8
 1270 0033 26010000 		.4byte	.LASF1
 1271 0037 02       		.uleb128 0x2
 1272 0038 02       		.byte	0x2
 1273 0039 05       		.byte	0x5
 1274 003a 42010000 		.4byte	.LASF2
 1275 003e 02       		.uleb128 0x2
 1276 003f 02       		.byte	0x2
 1277 0040 07       		.byte	0x7
 1278 0041 5A000000 		.4byte	.LASF3
 1279 0045 02       		.uleb128 0x2
 1280 0046 04       		.byte	0x4
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 52


 1281 0047 05       		.byte	0x5
 1282 0048 7D020000 		.4byte	.LASF4
 1283 004c 02       		.uleb128 0x2
 1284 004d 04       		.byte	0x4
 1285 004e 07       		.byte	0x7
 1286 004f EB000000 		.4byte	.LASF5
 1287 0053 02       		.uleb128 0x2
 1288 0054 08       		.byte	0x8
 1289 0055 05       		.byte	0x5
 1290 0056 00000000 		.4byte	.LASF6
 1291 005a 02       		.uleb128 0x2
 1292 005b 08       		.byte	0x8
 1293 005c 07       		.byte	0x7
 1294 005d CA010000 		.4byte	.LASF7
 1295 0061 03       		.uleb128 0x3
 1296 0062 04       		.byte	0x4
 1297 0063 05       		.byte	0x5
 1298 0064 696E7400 		.ascii	"int\000"
 1299 0068 02       		.uleb128 0x2
 1300 0069 04       		.byte	0x4
 1301 006a 07       		.byte	0x7
 1302 006b A6010000 		.4byte	.LASF8
 1303 006f 04       		.uleb128 0x4
 1304 0070 FD000000 		.4byte	.LASF9
 1305 0074 02       		.byte	0x2
 1306 0075 4C       		.byte	0x4c
 1307 0076 30000000 		.4byte	0x30
 1308 007a 04       		.uleb128 0x4
 1309 007b 4C010000 		.4byte	.LASF10
 1310 007f 02       		.byte	0x2
 1311 0080 4D       		.byte	0x4d
 1312 0081 3E000000 		.4byte	0x3e
 1313 0085 02       		.uleb128 0x2
 1314 0086 04       		.byte	0x4
 1315 0087 04       		.byte	0x4
 1316 0088 AC000000 		.4byte	.LASF11
 1317 008c 02       		.uleb128 0x2
 1318 008d 08       		.byte	0x8
 1319 008e 04       		.byte	0x4
 1320 008f 34010000 		.4byte	.LASF12
 1321 0093 04       		.uleb128 0x4
 1322 0094 BE000000 		.4byte	.LASF13
 1323 0098 02       		.byte	0x2
 1324 0099 5D       		.byte	0x5d
 1325 009a 9E000000 		.4byte	0x9e
 1326 009e 02       		.uleb128 0x2
 1327 009f 01       		.byte	0x1
 1328 00a0 08       		.byte	0x8
 1329 00a1 26020000 		.4byte	.LASF14
 1330 00a5 05       		.uleb128 0x5
 1331 00a6 04       		.byte	0x4
 1332 00a7 07       		.byte	0x7
 1333 00a8 06       		.uleb128 0x6
 1334 00a9 01       		.byte	0x1
 1335 00aa 1A000000 		.4byte	.LASF15
 1336 00ae 01       		.byte	0x1
 1337 00af 49       		.byte	0x49
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 53


 1338 00b0 01       		.byte	0x1
 1339 00b1 00000000 		.4byte	.LFB0
 1340 00b5 2A000000 		.4byte	.LFE0
 1341 00b9 00000000 		.4byte	.LLST0
 1342 00bd 06       		.uleb128 0x6
 1343 00be 01       		.byte	0x1
 1344 00bf 0E000000 		.4byte	.LASF16
 1345 00c3 01       		.byte	0x1
 1346 00c4 65       		.byte	0x65
 1347 00c5 01       		.byte	0x1
 1348 00c6 00000000 		.4byte	.LFB1
 1349 00ca 34000000 		.4byte	.LFE1
 1350 00ce 2B000000 		.4byte	.LLST1
 1351 00d2 07       		.uleb128 0x7
 1352 00d3 01       		.byte	0x1
 1353 00d4 A0020000 		.4byte	.LASF17
 1354 00d8 01       		.byte	0x1
 1355 00d9 AE       		.byte	0xae
 1356 00da 01       		.byte	0x1
 1357 00db 00000000 		.4byte	.LFB2
 1358 00df 3E000000 		.4byte	.LFE2
 1359 00e3 56000000 		.4byte	.LLST2
 1360 00e7 FA000000 		.4byte	0xfa
 1361 00eb 08       		.uleb128 0x8
 1362 00ec 15010000 		.4byte	.LASF19
 1363 00f0 01       		.byte	0x1
 1364 00f1 B0       		.byte	0xb0
 1365 00f2 6F000000 		.4byte	0x6f
 1366 00f6 02       		.byte	0x2
 1367 00f7 91       		.byte	0x91
 1368 00f8 77       		.sleb128 -9
 1369 00f9 00       		.byte	0x0
 1370 00fa 07       		.uleb128 0x7
 1371 00fb 01       		.byte	0x1
 1372 00fc DF000000 		.4byte	.LASF18
 1373 0100 01       		.byte	0x1
 1374 0101 E3       		.byte	0xe3
 1375 0102 01       		.byte	0x1
 1376 0103 00000000 		.4byte	.LFB3
 1377 0107 3C000000 		.4byte	.LFE3
 1378 010b 8D000000 		.4byte	.LLST3
 1379 010f 22010000 		.4byte	0x122
 1380 0113 08       		.uleb128 0x8
 1381 0114 15010000 		.4byte	.LASF19
 1382 0118 01       		.byte	0x1
 1383 0119 E5       		.byte	0xe5
 1384 011a 6F000000 		.4byte	0x6f
 1385 011e 02       		.byte	0x2
 1386 011f 91       		.byte	0x91
 1387 0120 77       		.sleb128 -9
 1388 0121 00       		.byte	0x0
 1389 0122 09       		.uleb128 0x9
 1390 0123 01       		.byte	0x1
 1391 0124 C4000000 		.4byte	.LASF26
 1392 0128 01       		.byte	0x1
 1393 0129 1901     		.2byte	0x119
 1394 012b 01       		.byte	0x1
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 54


 1395 012c 6F000000 		.4byte	0x6f
 1396 0130 00000000 		.4byte	.LFB4
 1397 0134 10000000 		.4byte	.LFE4
 1398 0138 C4000000 		.4byte	.LLST4
 1399 013c 0A       		.uleb128 0xa
 1400 013d 01       		.byte	0x1
 1401 013e 27000000 		.4byte	.LASF20
 1402 0142 01       		.byte	0x1
 1403 0143 3101     		.2byte	0x131
 1404 0145 01       		.byte	0x1
 1405 0146 00000000 		.4byte	.LFB5
 1406 014a 14000000 		.4byte	.LFE5
 1407 014e EF000000 		.4byte	.LLST5
 1408 0152 66010000 		.4byte	0x166
 1409 0156 0B       		.uleb128 0xb
 1410 0157 03010000 		.4byte	.LASF22
 1411 015b 01       		.byte	0x1
 1412 015c 3101     		.2byte	0x131
 1413 015e 6F000000 		.4byte	0x6f
 1414 0162 02       		.byte	0x2
 1415 0163 91       		.byte	0x91
 1416 0164 77       		.sleb128 -9
 1417 0165 00       		.byte	0x0
 1418 0166 0A       		.uleb128 0xa
 1419 0167 01       		.byte	0x1
 1420 0168 86020000 		.4byte	.LASF21
 1421 016c 01       		.byte	0x1
 1422 016d C803     		.2byte	0x3c8
 1423 016f 01       		.byte	0x1
 1424 0170 00000000 		.4byte	.LFB6
 1425 0174 20000000 		.4byte	.LFE6
 1426 0178 26010000 		.4byte	.LLST6
 1427 017c 90010000 		.4byte	0x190
 1428 0180 0B       		.uleb128 0xb
 1429 0181 3B010000 		.4byte	.LASF23
 1430 0185 01       		.byte	0x1
 1431 0186 C803     		.2byte	0x3c8
 1432 0188 6F000000 		.4byte	0x6f
 1433 018c 02       		.byte	0x2
 1434 018d 91       		.byte	0x91
 1435 018e 77       		.sleb128 -9
 1436 018f 00       		.byte	0x0
 1437 0190 0A       		.uleb128 0xa
 1438 0191 01       		.byte	0x1
 1439 0192 55020000 		.4byte	.LASF24
 1440 0196 01       		.byte	0x1
 1441 0197 EA03     		.2byte	0x3ea
 1442 0199 01       		.byte	0x1
 1443 019a 00000000 		.4byte	.LFB7
 1444 019e 2E000000 		.4byte	.LFE7
 1445 01a2 5D010000 		.4byte	.LLST7
 1446 01a6 BA010000 		.4byte	0x1ba
 1447 01aa 0B       		.uleb128 0xb
 1448 01ab 11020000 		.4byte	.LASF25
 1449 01af 01       		.byte	0x1
 1450 01b0 EA03     		.2byte	0x3ea
 1451 01b2 6F000000 		.4byte	0x6f
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 55


 1452 01b6 02       		.byte	0x2
 1453 01b7 91       		.byte	0x91
 1454 01b8 77       		.sleb128 -9
 1455 01b9 00       		.byte	0x0
 1456 01ba 09       		.uleb128 0x9
 1457 01bb 01       		.byte	0x1
 1458 01bc 85000000 		.4byte	.LASF27
 1459 01c0 01       		.byte	0x1
 1460 01c1 2E04     		.2byte	0x42e
 1461 01c3 01       		.byte	0x1
 1462 01c4 6F000000 		.4byte	0x6f
 1463 01c8 00000000 		.4byte	.LFB8
 1464 01cc 18000000 		.4byte	.LFE8
 1465 01d0 94010000 		.4byte	.LLST8
 1466 01d4 0A       		.uleb128 0xa
 1467 01d5 01       		.byte	0x1
 1468 01d6 97010000 		.4byte	.LASF28
 1469 01da 01       		.byte	0x1
 1470 01db 5204     		.2byte	0x452
 1471 01dd 01       		.byte	0x1
 1472 01de 00000000 		.4byte	.LFB9
 1473 01e2 34000000 		.4byte	.LFE9
 1474 01e6 BF010000 		.4byte	.LLST9
 1475 01ea FE010000 		.4byte	0x1fe
 1476 01ee 0B       		.uleb128 0xb
 1477 01ef 11020000 		.4byte	.LASF25
 1478 01f3 01       		.byte	0x1
 1479 01f4 5204     		.2byte	0x452
 1480 01f6 6F000000 		.4byte	0x6f
 1481 01fa 02       		.byte	0x2
 1482 01fb 91       		.byte	0x91
 1483 01fc 77       		.sleb128 -9
 1484 01fd 00       		.byte	0x0
 1485 01fe 0A       		.uleb128 0xa
 1486 01ff 01       		.byte	0x1
 1487 0200 BA020000 		.4byte	.LASF29
 1488 0204 01       		.byte	0x1
 1489 0205 AE04     		.2byte	0x4ae
 1490 0207 01       		.byte	0x1
 1491 0208 00000000 		.4byte	.LFB10
 1492 020c 48000000 		.4byte	.LFE10
 1493 0210 F6010000 		.4byte	.LLST10
 1494 0214 37020000 		.4byte	0x237
 1495 0218 0B       		.uleb128 0xb
 1496 0219 99000000 		.4byte	.LASF30
 1497 021d 01       		.byte	0x1
 1498 021e AE04     		.2byte	0x4ae
 1499 0220 37020000 		.4byte	0x237
 1500 0224 02       		.byte	0x2
 1501 0225 91       		.byte	0x91
 1502 0226 6C       		.sleb128 -20
 1503 0227 0C       		.uleb128 0xc
 1504 0228 D0020000 		.4byte	.LASF31
 1505 022c 01       		.byte	0x1
 1506 022d B004     		.2byte	0x4b0
 1507 022f 7A000000 		.4byte	0x7a
 1508 0233 02       		.byte	0x2
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 56


 1509 0234 91       		.byte	0x91
 1510 0235 76       		.sleb128 -10
 1511 0236 00       		.byte	0x0
 1512 0237 0D       		.uleb128 0xd
 1513 0238 04       		.byte	0x4
 1514 0239 3D020000 		.4byte	0x23d
 1515 023d 0E       		.uleb128 0xe
 1516 023e 93000000 		.4byte	0x93
 1517 0242 0A       		.uleb128 0xa
 1518 0243 01       		.byte	0x1
 1519 0244 01020000 		.4byte	.LASF32
 1520 0248 01       		.byte	0x1
 1521 0249 D404     		.2byte	0x4d4
 1522 024b 01       		.byte	0x1
 1523 024c 00000000 		.4byte	.LFB11
 1524 0250 46000000 		.4byte	.LFE11
 1525 0254 2D020000 		.4byte	.LLST11
 1526 0258 8A020000 		.4byte	0x28a
 1527 025c 0B       		.uleb128 0xb
 1528 025d 99000000 		.4byte	.LASF30
 1529 0261 01       		.byte	0x1
 1530 0262 D404     		.2byte	0x4d4
 1531 0264 8A020000 		.4byte	0x28a
 1532 0268 02       		.byte	0x2
 1533 0269 91       		.byte	0x91
 1534 026a 6C       		.sleb128 -20
 1535 026b 0B       		.uleb128 0xb
 1536 026c 0B010000 		.4byte	.LASF33
 1537 0270 01       		.byte	0x1
 1538 0271 D404     		.2byte	0x4d4
 1539 0273 6F000000 		.4byte	0x6f
 1540 0277 02       		.byte	0x2
 1541 0278 91       		.byte	0x91
 1542 0279 6B       		.sleb128 -21
 1543 027a 0C       		.uleb128 0xc
 1544 027b D0020000 		.4byte	.LASF31
 1545 027f 01       		.byte	0x1
 1546 0280 D704     		.2byte	0x4d7
 1547 0282 6F000000 		.4byte	0x6f
 1548 0286 02       		.byte	0x2
 1549 0287 91       		.byte	0x91
 1550 0288 77       		.sleb128 -9
 1551 0289 00       		.byte	0x0
 1552 028a 0D       		.uleb128 0xd
 1553 028b 04       		.byte	0x4
 1554 028c 90020000 		.4byte	0x290
 1555 0290 0E       		.uleb128 0xe
 1556 0291 6F000000 		.4byte	0x6f
 1557 0295 0A       		.uleb128 0xa
 1558 0296 01       		.byte	0x1
 1559 0297 E1010000 		.4byte	.LASF34
 1560 029b 01       		.byte	0x1
 1561 029c F904     		.2byte	0x4f9
 1562 029e 01       		.byte	0x1
 1563 029f 00000000 		.4byte	.LFB12
 1564 02a3 38000000 		.4byte	.LFE12
 1565 02a7 64020000 		.4byte	.LLST12
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 57


 1566 02ab BF020000 		.4byte	0x2bf
 1567 02af 0B       		.uleb128 0xb
 1568 02b0 11020000 		.4byte	.LASF25
 1569 02b4 01       		.byte	0x1
 1570 02b5 F904     		.2byte	0x4f9
 1571 02b7 6F000000 		.4byte	0x6f
 1572 02bb 02       		.byte	0x2
 1573 02bc 91       		.byte	0x91
 1574 02bd 77       		.sleb128 -9
 1575 02be 00       		.byte	0x0
 1576 02bf 0F       		.uleb128 0xf
 1577 02c0 01       		.byte	0x1
 1578 02c1 B3010000 		.4byte	.LASF46
 1579 02c5 01       		.byte	0x1
 1580 02c6 1E05     		.2byte	0x51e
 1581 02c8 01       		.byte	0x1
 1582 02c9 6F000000 		.4byte	0x6f
 1583 02cd 00000000 		.4byte	.LFB13
 1584 02d1 4A000000 		.4byte	.LFE13
 1585 02d5 9B020000 		.4byte	.LLST13
 1586 02d9 ED020000 		.4byte	0x2ed
 1587 02dd 0C       		.uleb128 0xc
 1588 02de CB020000 		.4byte	.LASF35
 1589 02e2 01       		.byte	0x1
 1590 02e3 2105     		.2byte	0x521
 1591 02e5 6F000000 		.4byte	0x6f
 1592 02e9 02       		.byte	0x2
 1593 02ea 91       		.byte	0x91
 1594 02eb 77       		.sleb128 -9
 1595 02ec 00       		.byte	0x0
 1596 02ed 0A       		.uleb128 0xa
 1597 02ee 01       		.byte	0x1
 1598 02ef 68020000 		.4byte	.LASF36
 1599 02f3 01       		.byte	0x1
 1600 02f4 7405     		.2byte	0x574
 1601 02f6 01       		.byte	0x1
 1602 02f7 00000000 		.4byte	.LFB14
 1603 02fb 54000000 		.4byte	.LFE14
 1604 02ff D2020000 		.4byte	.LLST14
 1605 0303 17030000 		.4byte	0x317
 1606 0307 0C       		.uleb128 0xc
 1607 0308 15010000 		.4byte	.LASF19
 1608 030c 01       		.byte	0x1
 1609 030d 7605     		.2byte	0x576
 1610 030f 6F000000 		.4byte	0x6f
 1611 0313 02       		.byte	0x2
 1612 0314 91       		.byte	0x91
 1613 0315 77       		.sleb128 -9
 1614 0316 00       		.byte	0x0
 1615 0317 0A       		.uleb128 0xa
 1616 0318 01       		.byte	0x1
 1617 0319 F0010000 		.4byte	.LASF37
 1618 031d 01       		.byte	0x1
 1619 031e CD05     		.2byte	0x5cd
 1620 0320 01       		.byte	0x1
 1621 0321 00000000 		.4byte	.LFB15
 1622 0325 CC000000 		.4byte	.LFE15
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 58


 1623 0329 09030000 		.4byte	.LLST15
 1624 032d 6C030000 		.4byte	0x36c
 1625 0331 0B       		.uleb128 0xb
 1626 0332 4D020000 		.4byte	.LASF38
 1627 0336 01       		.byte	0x1
 1628 0337 CD05     		.2byte	0x5cd
 1629 0339 6F000000 		.4byte	0x6f
 1630 033d 02       		.byte	0x2
 1631 033e 91       		.byte	0x91
 1632 033f 6F       		.sleb128 -17
 1633 0340 10       		.uleb128 0x10
 1634 0341 18000000 		.4byte	.LBB2
 1635 0345 C2000000 		.4byte	.LBE2
 1636 0349 0C       		.uleb128 0xc
 1637 034a 52000000 		.4byte	.LASF39
 1638 034e 01       		.byte	0x1
 1639 034f D505     		.2byte	0x5d5
 1640 0351 6F000000 		.4byte	0x6f
 1641 0355 02       		.byte	0x2
 1642 0356 91       		.byte	0x91
 1643 0357 77       		.sleb128 -9
 1644 0358 0C       		.uleb128 0xc
 1645 0359 1C020000 		.4byte	.LASF40
 1646 035d 01       		.byte	0x1
 1647 035e FB05     		.2byte	0x5fb
 1648 0360 6F000000 		.4byte	0x6f
 1649 0364 05       		.byte	0x5
 1650 0365 03       		.byte	0x3
 1651 0366 01000000 		.4byte	tx_period.2139
 1652 036a 00       		.byte	0x0
 1653 036b 00       		.byte	0x0
 1654 036c 0A       		.uleb128 0xa
 1655 036d 01       		.byte	0x1
 1656 036e 6D000000 		.4byte	.LASF41
 1657 0372 01       		.byte	0x1
 1658 0373 4606     		.2byte	0x646
 1659 0375 01       		.byte	0x1
 1660 0376 00000000 		.4byte	.LFB16
 1661 037a 14000000 		.4byte	.LFE16
 1662 037e 40030000 		.4byte	.LLST16
 1663 0382 96030000 		.4byte	0x396
 1664 0386 0B       		.uleb128 0xb
 1665 0387 B2000000 		.4byte	.LASF42
 1666 038b 01       		.byte	0x1
 1667 038c 4606     		.2byte	0x646
 1668 038e 6F000000 		.4byte	0x6f
 1669 0392 02       		.byte	0x2
 1670 0393 91       		.byte	0x91
 1671 0394 77       		.sleb128 -9
 1672 0395 00       		.byte	0x0
 1673 0396 11       		.uleb128 0x11
 1674 0397 43000000 		.4byte	.LASF47
 1675 039b 01       		.byte	0x1
 1676 039c 1C       		.byte	0x1c
 1677 039d 6F000000 		.4byte	0x6f
 1678 03a1 01       		.byte	0x1
 1679 03a2 05       		.byte	0x5
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 59


 1680 03a3 03       		.byte	0x3
 1681 03a4 00000000 		.4byte	UART_1_initVar
 1682 03a8 00       		.byte	0x0
 1683              		.section	.debug_abbrev
 1684 0000 01       		.uleb128 0x1
 1685 0001 11       		.uleb128 0x11
 1686 0002 01       		.byte	0x1
 1687 0003 25       		.uleb128 0x25
 1688 0004 0E       		.uleb128 0xe
 1689 0005 13       		.uleb128 0x13
 1690 0006 0B       		.uleb128 0xb
 1691 0007 03       		.uleb128 0x3
 1692 0008 0E       		.uleb128 0xe
 1693 0009 1B       		.uleb128 0x1b
 1694 000a 0E       		.uleb128 0xe
 1695 000b 11       		.uleb128 0x11
 1696 000c 01       		.uleb128 0x1
 1697 000d 52       		.uleb128 0x52
 1698 000e 01       		.uleb128 0x1
 1699 000f 55       		.uleb128 0x55
 1700 0010 06       		.uleb128 0x6
 1701 0011 10       		.uleb128 0x10
 1702 0012 06       		.uleb128 0x6
 1703 0013 00       		.byte	0x0
 1704 0014 00       		.byte	0x0
 1705 0015 02       		.uleb128 0x2
 1706 0016 24       		.uleb128 0x24
 1707 0017 00       		.byte	0x0
 1708 0018 0B       		.uleb128 0xb
 1709 0019 0B       		.uleb128 0xb
 1710 001a 3E       		.uleb128 0x3e
 1711 001b 0B       		.uleb128 0xb
 1712 001c 03       		.uleb128 0x3
 1713 001d 0E       		.uleb128 0xe
 1714 001e 00       		.byte	0x0
 1715 001f 00       		.byte	0x0
 1716 0020 03       		.uleb128 0x3
 1717 0021 24       		.uleb128 0x24
 1718 0022 00       		.byte	0x0
 1719 0023 0B       		.uleb128 0xb
 1720 0024 0B       		.uleb128 0xb
 1721 0025 3E       		.uleb128 0x3e
 1722 0026 0B       		.uleb128 0xb
 1723 0027 03       		.uleb128 0x3
 1724 0028 08       		.uleb128 0x8
 1725 0029 00       		.byte	0x0
 1726 002a 00       		.byte	0x0
 1727 002b 04       		.uleb128 0x4
 1728 002c 16       		.uleb128 0x16
 1729 002d 00       		.byte	0x0
 1730 002e 03       		.uleb128 0x3
 1731 002f 0E       		.uleb128 0xe
 1732 0030 3A       		.uleb128 0x3a
 1733 0031 0B       		.uleb128 0xb
 1734 0032 3B       		.uleb128 0x3b
 1735 0033 0B       		.uleb128 0xb
 1736 0034 49       		.uleb128 0x49
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 60


 1737 0035 13       		.uleb128 0x13
 1738 0036 00       		.byte	0x0
 1739 0037 00       		.byte	0x0
 1740 0038 05       		.uleb128 0x5
 1741 0039 24       		.uleb128 0x24
 1742 003a 00       		.byte	0x0
 1743 003b 0B       		.uleb128 0xb
 1744 003c 0B       		.uleb128 0xb
 1745 003d 3E       		.uleb128 0x3e
 1746 003e 0B       		.uleb128 0xb
 1747 003f 00       		.byte	0x0
 1748 0040 00       		.byte	0x0
 1749 0041 06       		.uleb128 0x6
 1750 0042 2E       		.uleb128 0x2e
 1751 0043 00       		.byte	0x0
 1752 0044 3F       		.uleb128 0x3f
 1753 0045 0C       		.uleb128 0xc
 1754 0046 03       		.uleb128 0x3
 1755 0047 0E       		.uleb128 0xe
 1756 0048 3A       		.uleb128 0x3a
 1757 0049 0B       		.uleb128 0xb
 1758 004a 3B       		.uleb128 0x3b
 1759 004b 0B       		.uleb128 0xb
 1760 004c 27       		.uleb128 0x27
 1761 004d 0C       		.uleb128 0xc
 1762 004e 11       		.uleb128 0x11
 1763 004f 01       		.uleb128 0x1
 1764 0050 12       		.uleb128 0x12
 1765 0051 01       		.uleb128 0x1
 1766 0052 40       		.uleb128 0x40
 1767 0053 06       		.uleb128 0x6
 1768 0054 00       		.byte	0x0
 1769 0055 00       		.byte	0x0
 1770 0056 07       		.uleb128 0x7
 1771 0057 2E       		.uleb128 0x2e
 1772 0058 01       		.byte	0x1
 1773 0059 3F       		.uleb128 0x3f
 1774 005a 0C       		.uleb128 0xc
 1775 005b 03       		.uleb128 0x3
 1776 005c 0E       		.uleb128 0xe
 1777 005d 3A       		.uleb128 0x3a
 1778 005e 0B       		.uleb128 0xb
 1779 005f 3B       		.uleb128 0x3b
 1780 0060 0B       		.uleb128 0xb
 1781 0061 27       		.uleb128 0x27
 1782 0062 0C       		.uleb128 0xc
 1783 0063 11       		.uleb128 0x11
 1784 0064 01       		.uleb128 0x1
 1785 0065 12       		.uleb128 0x12
 1786 0066 01       		.uleb128 0x1
 1787 0067 40       		.uleb128 0x40
 1788 0068 06       		.uleb128 0x6
 1789 0069 01       		.uleb128 0x1
 1790 006a 13       		.uleb128 0x13
 1791 006b 00       		.byte	0x0
 1792 006c 00       		.byte	0x0
 1793 006d 08       		.uleb128 0x8
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 61


 1794 006e 34       		.uleb128 0x34
 1795 006f 00       		.byte	0x0
 1796 0070 03       		.uleb128 0x3
 1797 0071 0E       		.uleb128 0xe
 1798 0072 3A       		.uleb128 0x3a
 1799 0073 0B       		.uleb128 0xb
 1800 0074 3B       		.uleb128 0x3b
 1801 0075 0B       		.uleb128 0xb
 1802 0076 49       		.uleb128 0x49
 1803 0077 13       		.uleb128 0x13
 1804 0078 02       		.uleb128 0x2
 1805 0079 0A       		.uleb128 0xa
 1806 007a 00       		.byte	0x0
 1807 007b 00       		.byte	0x0
 1808 007c 09       		.uleb128 0x9
 1809 007d 2E       		.uleb128 0x2e
 1810 007e 00       		.byte	0x0
 1811 007f 3F       		.uleb128 0x3f
 1812 0080 0C       		.uleb128 0xc
 1813 0081 03       		.uleb128 0x3
 1814 0082 0E       		.uleb128 0xe
 1815 0083 3A       		.uleb128 0x3a
 1816 0084 0B       		.uleb128 0xb
 1817 0085 3B       		.uleb128 0x3b
 1818 0086 05       		.uleb128 0x5
 1819 0087 27       		.uleb128 0x27
 1820 0088 0C       		.uleb128 0xc
 1821 0089 49       		.uleb128 0x49
 1822 008a 13       		.uleb128 0x13
 1823 008b 11       		.uleb128 0x11
 1824 008c 01       		.uleb128 0x1
 1825 008d 12       		.uleb128 0x12
 1826 008e 01       		.uleb128 0x1
 1827 008f 40       		.uleb128 0x40
 1828 0090 06       		.uleb128 0x6
 1829 0091 00       		.byte	0x0
 1830 0092 00       		.byte	0x0
 1831 0093 0A       		.uleb128 0xa
 1832 0094 2E       		.uleb128 0x2e
 1833 0095 01       		.byte	0x1
 1834 0096 3F       		.uleb128 0x3f
 1835 0097 0C       		.uleb128 0xc
 1836 0098 03       		.uleb128 0x3
 1837 0099 0E       		.uleb128 0xe
 1838 009a 3A       		.uleb128 0x3a
 1839 009b 0B       		.uleb128 0xb
 1840 009c 3B       		.uleb128 0x3b
 1841 009d 05       		.uleb128 0x5
 1842 009e 27       		.uleb128 0x27
 1843 009f 0C       		.uleb128 0xc
 1844 00a0 11       		.uleb128 0x11
 1845 00a1 01       		.uleb128 0x1
 1846 00a2 12       		.uleb128 0x12
 1847 00a3 01       		.uleb128 0x1
 1848 00a4 40       		.uleb128 0x40
 1849 00a5 06       		.uleb128 0x6
 1850 00a6 01       		.uleb128 0x1
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 62


 1851 00a7 13       		.uleb128 0x13
 1852 00a8 00       		.byte	0x0
 1853 00a9 00       		.byte	0x0
 1854 00aa 0B       		.uleb128 0xb
 1855 00ab 05       		.uleb128 0x5
 1856 00ac 00       		.byte	0x0
 1857 00ad 03       		.uleb128 0x3
 1858 00ae 0E       		.uleb128 0xe
 1859 00af 3A       		.uleb128 0x3a
 1860 00b0 0B       		.uleb128 0xb
 1861 00b1 3B       		.uleb128 0x3b
 1862 00b2 05       		.uleb128 0x5
 1863 00b3 49       		.uleb128 0x49
 1864 00b4 13       		.uleb128 0x13
 1865 00b5 02       		.uleb128 0x2
 1866 00b6 0A       		.uleb128 0xa
 1867 00b7 00       		.byte	0x0
 1868 00b8 00       		.byte	0x0
 1869 00b9 0C       		.uleb128 0xc
 1870 00ba 34       		.uleb128 0x34
 1871 00bb 00       		.byte	0x0
 1872 00bc 03       		.uleb128 0x3
 1873 00bd 0E       		.uleb128 0xe
 1874 00be 3A       		.uleb128 0x3a
 1875 00bf 0B       		.uleb128 0xb
 1876 00c0 3B       		.uleb128 0x3b
 1877 00c1 05       		.uleb128 0x5
 1878 00c2 49       		.uleb128 0x49
 1879 00c3 13       		.uleb128 0x13
 1880 00c4 02       		.uleb128 0x2
 1881 00c5 0A       		.uleb128 0xa
 1882 00c6 00       		.byte	0x0
 1883 00c7 00       		.byte	0x0
 1884 00c8 0D       		.uleb128 0xd
 1885 00c9 0F       		.uleb128 0xf
 1886 00ca 00       		.byte	0x0
 1887 00cb 0B       		.uleb128 0xb
 1888 00cc 0B       		.uleb128 0xb
 1889 00cd 49       		.uleb128 0x49
 1890 00ce 13       		.uleb128 0x13
 1891 00cf 00       		.byte	0x0
 1892 00d0 00       		.byte	0x0
 1893 00d1 0E       		.uleb128 0xe
 1894 00d2 26       		.uleb128 0x26
 1895 00d3 00       		.byte	0x0
 1896 00d4 49       		.uleb128 0x49
 1897 00d5 13       		.uleb128 0x13
 1898 00d6 00       		.byte	0x0
 1899 00d7 00       		.byte	0x0
 1900 00d8 0F       		.uleb128 0xf
 1901 00d9 2E       		.uleb128 0x2e
 1902 00da 01       		.byte	0x1
 1903 00db 3F       		.uleb128 0x3f
 1904 00dc 0C       		.uleb128 0xc
 1905 00dd 03       		.uleb128 0x3
 1906 00de 0E       		.uleb128 0xe
 1907 00df 3A       		.uleb128 0x3a
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 63


 1908 00e0 0B       		.uleb128 0xb
 1909 00e1 3B       		.uleb128 0x3b
 1910 00e2 05       		.uleb128 0x5
 1911 00e3 27       		.uleb128 0x27
 1912 00e4 0C       		.uleb128 0xc
 1913 00e5 49       		.uleb128 0x49
 1914 00e6 13       		.uleb128 0x13
 1915 00e7 11       		.uleb128 0x11
 1916 00e8 01       		.uleb128 0x1
 1917 00e9 12       		.uleb128 0x12
 1918 00ea 01       		.uleb128 0x1
 1919 00eb 40       		.uleb128 0x40
 1920 00ec 06       		.uleb128 0x6
 1921 00ed 01       		.uleb128 0x1
 1922 00ee 13       		.uleb128 0x13
 1923 00ef 00       		.byte	0x0
 1924 00f0 00       		.byte	0x0
 1925 00f1 10       		.uleb128 0x10
 1926 00f2 0B       		.uleb128 0xb
 1927 00f3 01       		.byte	0x1
 1928 00f4 11       		.uleb128 0x11
 1929 00f5 01       		.uleb128 0x1
 1930 00f6 12       		.uleb128 0x12
 1931 00f7 01       		.uleb128 0x1
 1932 00f8 00       		.byte	0x0
 1933 00f9 00       		.byte	0x0
 1934 00fa 11       		.uleb128 0x11
 1935 00fb 34       		.uleb128 0x34
 1936 00fc 00       		.byte	0x0
 1937 00fd 03       		.uleb128 0x3
 1938 00fe 0E       		.uleb128 0xe
 1939 00ff 3A       		.uleb128 0x3a
 1940 0100 0B       		.uleb128 0xb
 1941 0101 3B       		.uleb128 0x3b
 1942 0102 0B       		.uleb128 0xb
 1943 0103 49       		.uleb128 0x49
 1944 0104 13       		.uleb128 0x13
 1945 0105 3F       		.uleb128 0x3f
 1946 0106 0C       		.uleb128 0xc
 1947 0107 02       		.uleb128 0x2
 1948 0108 0A       		.uleb128 0xa
 1949 0109 00       		.byte	0x0
 1950 010a 00       		.byte	0x0
 1951 010b 00       		.byte	0x0
 1952              		.section	.debug_pubnames,"",%progbits
 1953 0000 A4010000 		.4byte	0x1a4
 1954 0004 0200     		.2byte	0x2
 1955 0006 00000000 		.4byte	.Ldebug_info0
 1956 000a A9030000 		.4byte	0x3a9
 1957 000e A8000000 		.4byte	0xa8
 1958 0012 55415254 		.ascii	"UART_1_Start\000"
 1958      5F315F53 
 1958      74617274 
 1958      00
 1959 001f BD000000 		.4byte	0xbd
 1960 0023 55415254 		.ascii	"UART_1_Init\000"
 1960      5F315F49 
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 64


 1960      6E697400 
 1961 002f D2000000 		.4byte	0xd2
 1962 0033 55415254 		.ascii	"UART_1_Enable\000"
 1962      5F315F45 
 1962      6E61626C 
 1962      6500
 1963 0041 FA000000 		.4byte	0xfa
 1964 0045 55415254 		.ascii	"UART_1_Stop\000"
 1964      5F315F53 
 1964      746F7000 
 1965 0051 22010000 		.4byte	0x122
 1966 0055 55415254 		.ascii	"UART_1_ReadControlRegister\000"
 1966      5F315F52 
 1966      65616443 
 1966      6F6E7472 
 1966      6F6C5265 
 1967 0070 3C010000 		.4byte	0x13c
 1968 0074 55415254 		.ascii	"UART_1_WriteControlRegister\000"
 1968      5F315F57 
 1968      72697465 
 1968      436F6E74 
 1968      726F6C52 
 1969 0090 66010000 		.4byte	0x166
 1970 0094 55415254 		.ascii	"UART_1_SetTxInterruptMode\000"
 1970      5F315F53 
 1970      65745478 
 1970      496E7465 
 1970      72727570 
 1971 00ae 90010000 		.4byte	0x190
 1972 00b2 55415254 		.ascii	"UART_1_WriteTxData\000"
 1972      5F315F57 
 1972      72697465 
 1972      54784461 
 1972      746100
 1973 00c5 BA010000 		.4byte	0x1ba
 1974 00c9 55415254 		.ascii	"UART_1_ReadTxStatus\000"
 1974      5F315F52 
 1974      65616454 
 1974      78537461 
 1974      74757300 
 1975 00dd D4010000 		.4byte	0x1d4
 1976 00e1 55415254 		.ascii	"UART_1_PutChar\000"
 1976      5F315F50 
 1976      75744368 
 1976      617200
 1977 00f0 FE010000 		.4byte	0x1fe
 1978 00f4 55415254 		.ascii	"UART_1_PutString\000"
 1978      5F315F50 
 1978      75745374 
 1978      72696E67 
 1978      00
 1979 0105 42020000 		.4byte	0x242
 1980 0109 55415254 		.ascii	"UART_1_PutArray\000"
 1980      5F315F50 
 1980      75744172 
 1980      72617900 
 1981 0119 95020000 		.4byte	0x295
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 65


 1982 011d 55415254 		.ascii	"UART_1_PutCRLF\000"
 1982      5F315F50 
 1982      75744352 
 1982      4C4600
 1983 012c BF020000 		.4byte	0x2bf
 1984 0130 55415254 		.ascii	"UART_1_GetTxBufferSize\000"
 1984      5F315F47 
 1984      65745478 
 1984      42756666 
 1984      65725369 
 1985 0147 ED020000 		.4byte	0x2ed
 1986 014b 55415254 		.ascii	"UART_1_ClearTxBuffer\000"
 1986      5F315F43 
 1986      6C656172 
 1986      54784275 
 1986      66666572 
 1987 0160 17030000 		.4byte	0x317
 1988 0164 55415254 		.ascii	"UART_1_SendBreak\000"
 1988      5F315F53 
 1988      656E6442 
 1988      7265616B 
 1988      00
 1989 0175 6C030000 		.4byte	0x36c
 1990 0179 55415254 		.ascii	"UART_1_SetTxAddressMode\000"
 1990      5F315F53 
 1990      65745478 
 1990      41646472 
 1990      6573734D 
 1991 0191 96030000 		.4byte	0x396
 1992 0195 55415254 		.ascii	"UART_1_initVar\000"
 1992      5F315F69 
 1992      6E697456 
 1992      617200
 1993 01a4 00000000 		.4byte	0x0
 1994              		.section	.debug_aranges,"",%progbits
 1995 0000 9C000000 		.4byte	0x9c
 1996 0004 0200     		.2byte	0x2
 1997 0006 00000000 		.4byte	.Ldebug_info0
 1998 000a 04       		.byte	0x4
 1999 000b 00       		.byte	0x0
 2000 000c 0000     		.2byte	0x0
 2001 000e 0000     		.2byte	0x0
 2002 0010 00000000 		.4byte	.LFB0
 2003 0014 2A000000 		.4byte	.LFE0-.LFB0
 2004 0018 00000000 		.4byte	.LFB1
 2005 001c 34000000 		.4byte	.LFE1-.LFB1
 2006 0020 00000000 		.4byte	.LFB2
 2007 0024 3E000000 		.4byte	.LFE2-.LFB2
 2008 0028 00000000 		.4byte	.LFB3
 2009 002c 3C000000 		.4byte	.LFE3-.LFB3
 2010 0030 00000000 		.4byte	.LFB4
 2011 0034 10000000 		.4byte	.LFE4-.LFB4
 2012 0038 00000000 		.4byte	.LFB5
 2013 003c 14000000 		.4byte	.LFE5-.LFB5
 2014 0040 00000000 		.4byte	.LFB6
 2015 0044 20000000 		.4byte	.LFE6-.LFB6
 2016 0048 00000000 		.4byte	.LFB7
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 66


 2017 004c 2E000000 		.4byte	.LFE7-.LFB7
 2018 0050 00000000 		.4byte	.LFB8
 2019 0054 18000000 		.4byte	.LFE8-.LFB8
 2020 0058 00000000 		.4byte	.LFB9
 2021 005c 34000000 		.4byte	.LFE9-.LFB9
 2022 0060 00000000 		.4byte	.LFB10
 2023 0064 48000000 		.4byte	.LFE10-.LFB10
 2024 0068 00000000 		.4byte	.LFB11
 2025 006c 46000000 		.4byte	.LFE11-.LFB11
 2026 0070 00000000 		.4byte	.LFB12
 2027 0074 38000000 		.4byte	.LFE12-.LFB12
 2028 0078 00000000 		.4byte	.LFB13
 2029 007c 4A000000 		.4byte	.LFE13-.LFB13
 2030 0080 00000000 		.4byte	.LFB14
 2031 0084 54000000 		.4byte	.LFE14-.LFB14
 2032 0088 00000000 		.4byte	.LFB15
 2033 008c CC000000 		.4byte	.LFE15-.LFB15
 2034 0090 00000000 		.4byte	.LFB16
 2035 0094 14000000 		.4byte	.LFE16-.LFB16
 2036 0098 00000000 		.4byte	0x0
 2037 009c 00000000 		.4byte	0x0
 2038              		.section	.debug_ranges,"",%progbits
 2039              	.Ldebug_ranges0:
 2040 0000 00000000 		.4byte	.Ltext0
 2041 0004 00000000 		.4byte	.Letext0
 2042 0008 00000000 		.4byte	.LFB0
 2043 000c 2A000000 		.4byte	.LFE0
 2044 0010 00000000 		.4byte	.LFB1
 2045 0014 34000000 		.4byte	.LFE1
 2046 0018 00000000 		.4byte	.LFB2
 2047 001c 3E000000 		.4byte	.LFE2
 2048 0020 00000000 		.4byte	.LFB3
 2049 0024 3C000000 		.4byte	.LFE3
 2050 0028 00000000 		.4byte	.LFB4
 2051 002c 10000000 		.4byte	.LFE4
 2052 0030 00000000 		.4byte	.LFB5
 2053 0034 14000000 		.4byte	.LFE5
 2054 0038 00000000 		.4byte	.LFB6
 2055 003c 20000000 		.4byte	.LFE6
 2056 0040 00000000 		.4byte	.LFB7
 2057 0044 2E000000 		.4byte	.LFE7
 2058 0048 00000000 		.4byte	.LFB8
 2059 004c 18000000 		.4byte	.LFE8
 2060 0050 00000000 		.4byte	.LFB9
 2061 0054 34000000 		.4byte	.LFE9
 2062 0058 00000000 		.4byte	.LFB10
 2063 005c 48000000 		.4byte	.LFE10
 2064 0060 00000000 		.4byte	.LFB11
 2065 0064 46000000 		.4byte	.LFE11
 2066 0068 00000000 		.4byte	.LFB12
 2067 006c 38000000 		.4byte	.LFE12
 2068 0070 00000000 		.4byte	.LFB13
 2069 0074 4A000000 		.4byte	.LFE13
 2070 0078 00000000 		.4byte	.LFB14
 2071 007c 54000000 		.4byte	.LFE14
 2072 0080 00000000 		.4byte	.LFB15
 2073 0084 CC000000 		.4byte	.LFE15
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 67


 2074 0088 00000000 		.4byte	.LFB16
 2075 008c 14000000 		.4byte	.LFE16
 2076 0090 00000000 		.4byte	0x0
 2077 0094 00000000 		.4byte	0x0
 2078              		.section	.debug_str,"MS",%progbits,1
 2079              	.LASF6:
 2080 0000 6C6F6E67 		.ascii	"long long int\000"
 2080      206C6F6E 
 2080      6720696E 
 2080      7400
 2081              	.LASF16:
 2082 000e 55415254 		.ascii	"UART_1_Init\000"
 2082      5F315F49 
 2082      6E697400 
 2083              	.LASF15:
 2084 001a 55415254 		.ascii	"UART_1_Start\000"
 2084      5F315F53 
 2084      74617274 
 2084      00
 2085              	.LASF20:
 2086 0027 55415254 		.ascii	"UART_1_WriteControlRegister\000"
 2086      5F315F57 
 2086      72697465 
 2086      436F6E74 
 2086      726F6C52 
 2087              	.LASF47:
 2088 0043 55415254 		.ascii	"UART_1_initVar\000"
 2088      5F315F69 
 2088      6E697456 
 2088      617200
 2089              	.LASF39:
 2090 0052 746D7053 		.ascii	"tmpStat\000"
 2090      74617400 
 2091              	.LASF3:
 2092 005a 73686F72 		.ascii	"short unsigned int\000"
 2092      7420756E 
 2092      7369676E 
 2092      65642069 
 2092      6E7400
 2093              	.LASF41:
 2094 006d 55415254 		.ascii	"UART_1_SetTxAddressMode\000"
 2094      5F315F53 
 2094      65745478 
 2094      41646472 
 2094      6573734D 
 2095              	.LASF27:
 2096 0085 55415254 		.ascii	"UART_1_ReadTxStatus\000"
 2096      5F315F52 
 2096      65616454 
 2096      78537461 
 2096      74757300 
 2097              	.LASF30:
 2098 0099 73747269 		.ascii	"string\000"
 2098      6E6700
 2099              	.LASF43:
 2100 00a0 474E5520 		.ascii	"GNU C 4.4.1\000"
 2100      4320342E 
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 68


 2100      342E3100 
 2101              	.LASF11:
 2102 00ac 666C6F61 		.ascii	"float\000"
 2102      7400
 2103              	.LASF42:
 2104 00b2 61646472 		.ascii	"addressMode\000"
 2104      6573734D 
 2104      6F646500 
 2105              	.LASF13:
 2106 00be 63686172 		.ascii	"char8\000"
 2106      3800
 2107              	.LASF26:
 2108 00c4 55415254 		.ascii	"UART_1_ReadControlRegister\000"
 2108      5F315F52 
 2108      65616443 
 2108      6F6E7472 
 2108      6F6C5265 
 2109              	.LASF18:
 2110 00df 55415254 		.ascii	"UART_1_Stop\000"
 2110      5F315F53 
 2110      746F7000 
 2111              	.LASF5:
 2112 00eb 6C6F6E67 		.ascii	"long unsigned int\000"
 2112      20756E73 
 2112      69676E65 
 2112      6420696E 
 2112      7400
 2113              	.LASF9:
 2114 00fd 75696E74 		.ascii	"uint8\000"
 2114      3800
 2115              	.LASF22:
 2116 0103 636F6E74 		.ascii	"control\000"
 2116      726F6C00 
 2117              	.LASF33:
 2118 010b 62797465 		.ascii	"byteCount\000"
 2118      436F756E 
 2118      7400
 2119              	.LASF19:
 2120 0115 656E6162 		.ascii	"enableInterrupts\000"
 2120      6C65496E 
 2120      74657272 
 2120      75707473 
 2120      00
 2121              	.LASF1:
 2122 0126 756E7369 		.ascii	"unsigned char\000"
 2122      676E6564 
 2122      20636861 
 2122      7200
 2123              	.LASF12:
 2124 0134 646F7562 		.ascii	"double\000"
 2124      6C6500
 2125              	.LASF23:
 2126 013b 696E7453 		.ascii	"intSrc\000"
 2126      726300
 2127              	.LASF2:
 2128 0142 73686F72 		.ascii	"short int\000"
 2128      7420696E 
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 69


 2128      7400
 2129              	.LASF10:
 2130 014c 75696E74 		.ascii	"uint16\000"
 2130      313600
 2131              	.LASF45:
 2132 0153 433A5C55 		.ascii	"C:\\Users\\hoangp\\Documents\\GitHub\\EE542\\firmwa"
 2132      73657273 
 2132      5C686F61 
 2132      6E67705C 
 2132      446F6375 
 2133 0180 72655C69 		.ascii	"re\\invert\\invert.cydsn\000"
 2133      6E766572 
 2133      745C696E 
 2133      76657274 
 2133      2E637964 
 2134              	.LASF28:
 2135 0197 55415254 		.ascii	"UART_1_PutChar\000"
 2135      5F315F50 
 2135      75744368 
 2135      617200
 2136              	.LASF8:
 2137 01a6 756E7369 		.ascii	"unsigned int\000"
 2137      676E6564 
 2137      20696E74 
 2137      00
 2138              	.LASF46:
 2139 01b3 55415254 		.ascii	"UART_1_GetTxBufferSize\000"
 2139      5F315F47 
 2139      65745478 
 2139      42756666 
 2139      65725369 
 2140              	.LASF7:
 2141 01ca 6C6F6E67 		.ascii	"long long unsigned int\000"
 2141      206C6F6E 
 2141      6720756E 
 2141      7369676E 
 2141      65642069 
 2142              	.LASF34:
 2143 01e1 55415254 		.ascii	"UART_1_PutCRLF\000"
 2143      5F315F50 
 2143      75744352 
 2143      4C4600
 2144              	.LASF37:
 2145 01f0 55415254 		.ascii	"UART_1_SendBreak\000"
 2145      5F315F53 
 2145      656E6442 
 2145      7265616B 
 2145      00
 2146              	.LASF32:
 2147 0201 55415254 		.ascii	"UART_1_PutArray\000"
 2147      5F315F50 
 2147      75744172 
 2147      72617900 
 2148              	.LASF25:
 2149 0211 74784461 		.ascii	"txDataByte\000"
 2149      74614279 
 2149      746500
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 70


 2150              	.LASF40:
 2151 021c 74785F70 		.ascii	"tx_period\000"
 2151      6572696F 
 2151      6400
 2152              	.LASF14:
 2153 0226 63686172 		.ascii	"char\000"
 2153      00
 2154              	.LASF44:
 2155 022b 2E5C4765 		.ascii	".\\Generated_Source\\PSoC5\\UART_1.c\000"
 2155      6E657261 
 2155      7465645F 
 2155      536F7572 
 2155      63655C50 
 2156              	.LASF38:
 2157 024d 7265744D 		.ascii	"retMode\000"
 2157      6F646500 
 2158              	.LASF24:
 2159 0255 55415254 		.ascii	"UART_1_WriteTxData\000"
 2159      5F315F57 
 2159      72697465 
 2159      54784461 
 2159      746100
 2160              	.LASF36:
 2161 0268 55415254 		.ascii	"UART_1_ClearTxBuffer\000"
 2161      5F315F43 
 2161      6C656172 
 2161      54784275 
 2161      66666572 
 2162              	.LASF4:
 2163 027d 6C6F6E67 		.ascii	"long int\000"
 2163      20696E74 
 2163      00
 2164              	.LASF21:
 2165 0286 55415254 		.ascii	"UART_1_SetTxInterruptMode\000"
 2165      5F315F53 
 2165      65745478 
 2165      496E7465 
 2165      72727570 
 2166              	.LASF17:
 2167 02a0 55415254 		.ascii	"UART_1_Enable\000"
 2167      5F315F45 
 2167      6E61626C 
 2167      6500
 2168              	.LASF0:
 2169 02ae 7369676E 		.ascii	"signed char\000"
 2169      65642063 
 2169      68617200 
 2170              	.LASF29:
 2171 02ba 55415254 		.ascii	"UART_1_PutString\000"
 2171      5F315F50 
 2171      75745374 
 2171      72696E67 
 2171      00
 2172              	.LASF35:
 2173 02cb 73697A65 		.ascii	"size\000"
 2173      00
 2174              	.LASF31:
ARM GAS  C:\Users\hoangp\AppData\Local\Temp\ccaZgNws.s 			page 71


 2175 02d0 6275665F 		.ascii	"buf_index\000"
 2175      696E6465 
 2175      7800
 2176              		.ident	"GCC: (Sourcery G++ Lite 2010q1-188) 4.4.1"
